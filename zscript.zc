Version "3.4"

// See https://gitlab.com/Gutawer/gzdoom-gutamatics/
#include "U2P_Gutamatics/Include.zsc"

class UseToPickup : StaticEventHandler {
	U2P_PlayerState PlayerStates[MAXPLAYERS];
	Font MsgFont;
	private ThinkerIterator Drawables;
	
	override void OnRegister() {
		MsgFont = Font.FindFont('SMALLFONT');
		Drawables = ThinkerIterator.Create('U2P_ItemHighlight');
	}
	
	override void PlayerEntered(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (!PlayerStates[p])
			PlayerStates[p] = new("U2P_PlayerState");
		PlayerStates[p].Init(players[p], p);
	}
	
	override void PlayerRespawned(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (PlayerStates[p])
			PlayerStates[p].ClearFocus();
	}
	
	override void PlayerDisconnected(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (PlayerStates[p]) {
			PlayerStates[p].Destroy();
			PlayerStates[p] = null;
		}
	}
	
	override void RenderOverlay(RenderEvent evt) {
		if (automapactive || !playeringame[consoleplayer])
			return;
		
		U2P_DrawContext dc;
		dc.MsgFont = MsgFont;
		dc.InitFromRenderEvent(evt);
		
		Drawables.Reinit();
		for (let drawable = Drawables.Next(); drawable; drawable = Drawables.Next())
			U2P_ItemHighlight(drawable).Draw(dc);
	}
}

struct U2P_DrawContext ui {
	Actor Viewer;
	Vector3 ViewPos, ViewAngles;
	U2P_Matrix WorldToClip;
	double FracTic;
	float ViewerFOV;
	Font MsgFont;
	
	void InitFromRenderEvent(RenderEvent evt) {
		Viewer = evt.Camera;
		ViewPos = evt.ViewPos;
		ViewAngles = (evt.ViewAngle, evt.ViewPitch, evt.ViewRoll);
		FracTic = evt.FracTic;
		ViewerFOV = players[consoleplayer].FOV;
		Init();
	}
	
	// This needs to be called *after* ViewPos, ViewAngles, and ViewerFOV are set.
	void Init() {
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		WorldToClip = U2P_Matrix.worldToClip(ViewPos, ViewAngles.X, ViewAngles.Y, ViewAngles.Z, ViewerFOV);
	}
}

class U2P_PlayerState : Thinker {
	const ItemsCompactSize = 3;
	const HighlightFOV = 25.;
	
	U2P_ItemHighlight FocusedItem;
	PlayerInfo Player;
	uint8 SelectPhase;
	transient bool IsEnabled;
	transient CVar IsEnabledCVar;
	
	U2P_PlayerState Init(PlayerInfo player, int playerNum) {
		self.Player = player;
		
		// Target selection runs every 4 tics. In multiplayer with a lot of players, this could result in stuttering, from target selection happening for all of them at the same time (every fourth tic). So, we offset which of every fourth tic to perform target selection on, based on the player number. For example:
		// Player 0 will select targets on tic 0, 3, 6, …
		// Player 1 will select targets on tic 1, 4, 7, …
		// Player 2 will select targets on tic 2, 5, 8, …
		// Player 4 will select targets on tic 0, 3, 6, …
		// Player 5 will select targets on tic 1, 4, 7, …
		SelectPhase = playerNum & 3;
		
		return self;
	}
	
	void ClearFocus() {
		if (FocusedItem) {
			FocusedItem.FadeOut();
			FocusedItem = null;
		}
	}
	
	override void Tick() {
		// Clear the focused item, if appropriate.
		if (FocusedItem && !FocusedItem.Target)
			FocusedItem = null;
		
		// Update enabled status, PICKUP flag, etc.
		if (!IsEnabledCVar)
			IsEnabledCVar = CVar.GetCVar('usetopickup_enabled', Player);
		
		// Besides the cvar, don't apply to dead players or bots.
		let pp = Player.mo;
		if (IsEnabledCVar.GetBool() && Player.playerstate == PST_LIVE && !Player.bot) {
			IsEnabled = true;
			if (pp)
				pp.bPickup = false;
		}
		else if (IsEnabled) {
			IsEnabled = false;
			if (pp)
				pp.bPickup = GetDefaultByType(pp.GetClass()).bPickup;
			ClearFocus();
		}
		
		if (pp && IsEnabled && !((gametic + SelectPhase) & 3)) {
			Inventory origTarget = null, bestTarget = null;
			double bestDFC = HighlightFOV;
			bool valid;
			
			// Check the current focused item.
			if (FocusedItem) {
				origTarget = FocusedItem.Target;
				if (CheckTarget(pp, origTarget, bestDFC))
					bestTarget = origTarget;
			}
			
			// Look for the item that's closest to the center of the player actor's field of view.
			for (let i = BlockThingsIterator.Create(pp, usetopickup_fulluserange && pp is "PlayerPawn"? PlayerPawn(pp).UseRange : max(pp.Height, pp.Radius)); i.Next();)
			if (i.thing != bestTarget && i.thing is "Inventory" && CheckTarget(pp, i.thing, bestDFC))
				bestTarget = Inventory(i.thing);
			
			if (FocusedItem && (!bestTarget || bestTarget != origTarget)) {
				// We're now focusing on something other than what's currently focused (either nothing or a different actor), so clear the current focus.
				ClearFocus();
			}
			
			if (bestTarget && bestTarget != origTarget)
				// Got a new target to focus on.
				FocusedItem = new("U2P_ItemHighlight").Init(Player, bestTarget);
		}
		
		// Check if the player is allowed to pick up the focused item.
		if (
			IsEnabled &&
			pp &&
			FocusedItem &&
			FocusedItem.Target &&
			FocusedItem.Ready
		) {
			// If so, then block the usual effects of the use button.
			Player.usedown = true;
			
			// Check if the player wants to pick up the item.
			if (
				(Player.cmd.buttons & BT_USE) &&
				!(Player.oldbuttons & BT_USE)
			)
				FocusedItem.Target.Touch(pp);
		}
	}
	
	/**
	 * Checks whether a target is valid, and if so, updates bestDFC.
	 *
	 * The target is valid if:
	 * • It is within the given range of the viewer.
	 * • Its distance from the center of the viewer's field of view (that is, how far the viewer would need to look left/right/up/down to look straight at the target) is less than bestDFC.
	 *
	 * @param viewer The viewing actor.
	 * @param target The actor that may or may not be a valid target.
	 * @param bestDFC Distance-from-center of currently focused target. This is an out parameter; if the given target is valid, bestDFC will be updated with the DFC of the given target.
	 * @return true if the target is valid; false otherwise.
	 */
	static bool CheckTarget(Actor viewer, Actor target, in out double bestDFC) {
		if (
			// Does it exist at all?
			!target ||
			// Can it be picked up?
			!target.bSpecial
		)
			// Nope.
			return false;
		
		// Compute relevant points, distances, and angles.
		let viewPos = viewer.Pos;
		if (viewer.player)
			viewPos.Z = viewer.player.viewz;
		else
			viewPos.Z += viewer.Height / 2.;
		
		let targetPos = target.Pos;
		targetPos.Z += target.Height / 2.;
		targetPos.Z += target.GetBobOffset();
		
		let vecTo = level.Vec3Diff(viewPos, targetPos);
		let distTo = vecTo.Length();
		
		// Is it close enough?
		if (usetopickup_fulluserange && viewer is "PlayerPawn") {
			// Test by the viewer's use range.
			if (distTo > PlayerPawn(viewer).UseRange)
				return false;
		}
		else {
			// Test whether the actors are intersecting, ignoring viewpoints and angles.
			if (
				viewer.Distance2D(target) > max(viewer.Radius, target.Radius) ||
				viewer.Pos.Z > target.Pos.Z + target.Height ||
				target.Pos.Z > viewer.Pos.Z + viewer.Height
			)
				return false;
		}
		
		let dirTo = vecTo.Unit();
		let anglesTo = (
			atan2(dirTo.Y, dirTo.X),
			-asin(dirTo.Z)
		);
		Vector2 viewDA = (
			Actor.deltaangle(anglesTo.X, viewer.Angle),
			Actor.deltaangle(anglesTo.Y, viewer.Pitch)
		);
		let dfc = viewDA.Length();
		
		// Is it within acceptable angles?
		if (dfc >= bestDFC)
			return false;
		
		// Is there anything in the way?
		FTranslatedLineTarget trace;
		viewer.AimLineAttack(anglesTo.X, distTo, trace, target: target);
		if (trace.linetarget && trace.linetarget != target)
			return false;
		
		// All checks pass!
		bestDFC = dfc;
		return true;
	}
}

class U2P_ItemHighlight : Thinker {
	const FadeInRate = float(.14);
	const FadeOutRate = float(-.07);
	const FullOpacity = float(1.);
	
	Inventory Target;
	PlayerInfo Player;
	float Opacity;
	protected float OpacityIncrement;
	bool Ready;
	
	// Record this information so that the highlight can fade out, even if the item disappears.
	Vector3 TargetPos;
	double TargetHeight, TargetRadius;
	String TargetTag;
	
	U2P_ItemHighlight Init(PlayerInfo player, Inventory target) {
		self.Player = player;
		self.Target = target;
		OpacityIncrement = FadeInRate;
		return self;
	}
	
	override void Tick() {
		if (!Player) {
			Destroy();
			return;
		}
		
		switch (Player.playerstate) {
			case PST_DEAD:
			case PST_REBORN:
				// If player is dead, fade out.
				Target = null;
				break;
			
			case PST_ENTER:
			case PST_GONE:
				// If player isn't present at all, then this object is no longer valid, so bail.
				Destroy();
				return;
			
			// Otherwise, carry on.
		}
		
		if (Target) {
			TargetPos = Target.Pos;
			TargetPos.Z += Target.GetBobOffset();
			TargetTag = Target.GetTag(Target.GetClassName());
			TargetHeight = Target.Height;
			TargetRadius = Target.Radius;
		}
		else {
			// Target lost. Fade out.
			FadeOut();
		}
		
		if (OpacityIncrement)
			Opacity = clamp(Opacity + OpacityIncrement, 0., FullOpacity);
		
		if (Opacity == 0.) {
			// Fully faded out.
			Destroy();
			return;
		}
		
		Ready = Opacity == FullOpacity;
		if (Ready)
			// Fully visible.
			OpacityIncrement = 0;
	}
	
	void FadeOut() {
		if (OpacityIncrement >= 0.)
			OpacityIncrement = FadeOutRate;
	}
	
	const TextColor_Description = Font.CR_WHITE;
	const TextColor_KeyBind = Font.CR_GRAY;
	const TextColor_PressToUseMsg = Font.CR_WHITE;
	const BackgroundColor_KeyBind = Color(0xffffffe6);
	const BracketColor = Color(0xffffffff);
	const BracketTexName = "UseToPickup/bracket.png";
	private transient ui TextureID BracketTex;
	
	// Scale the brackets such that they're drawn 1:1 on a screen whose min(width,height) is this many pixels.
	const ScaleBase = 4000.;
	
	ui void Draw(U2P_DrawContext dc) {
		// Don't actually draw anything for anyone other than the console player.
		// Note that these highlighters have playsim effects too, so they still exist for other players; they just aren't drawn.
		if (Player != players[consoleplayer])
			return;
		
		// Don't bother drawing anything if opacity is zero!
		if (Opacity <= 0.)
			return;
		
		switch (Player.playerstate) {
			case PST_ENTER:
			case PST_GONE:
				// Similarly, if the owning player isn't in the game, don't draw anything.
				return;
		}
		
		// Look up the bracket texture, if needed.
		if (!BracketTex.IsValid()) {
			BracketTex = TexMan.CheckForTexture(BracketTexName, TexMan.Type_Any);
			if (!BracketTex.IsValid())
				ThrowAbortException("%s can't find required texture %s!", GetClassName(), BracketTexName);
		}
		
		// Top left, bottom right
		Vector2 screenCoord[2];
		
		// Adapted from Pixel Eater's Fill Spectre.
		for (let corner = 0; corner < 4; corner++) {
			// Compute one corner at a time.
			// The corner numbers are: 0 = top left, 1 = top right, 2 = bottom left, 3 = bottom right
			let vert = dc.ViewPos + LevelLocals.Vec3Diff(
				dc.ViewPos,
				TargetPos + (
					// `corner & 1` is only true for the top right and bottom right corners.
					sin(dc.Viewer.Angle) * TargetRadius * (corner & 1? 1. : -1.),
					cos(dc.Viewer.Angle) * TargetRadius * (corner & 1? -1. : 1.),
					// `corner & 2` is only true for the bottom left and bottom right corners.
					corner & 2? 0 : TargetHeight
				)
			);
			
			let ndc = dc.WorldToClip.multiplyVector3(vert).asVector3();
			
			if (ndc.Z > 1. || ndc.Z < -1.)
				// Out of camera view. Don't draw anything.
				// This is the reason why we store all four coordinates in the screenCoord and then loop over them again: if *any* of the coordinates are out of view, we need to not draw anything!
				return;
			
			let cornerCoord = U2P_GlobalMaths.ndcToViewPort(ndc);
			
			// That projects the corners of the sprite on the screen. Now, make a rectangle from the coordinates.
			if (!corner) {
				// For the first corner, just use that coordinate to start.
				screenCoord[0] = screenCoord[1] = cornerCoord;
			}
			else {
				// From there, stretch out the rectangle to fit the thing.
				screenCoord[0].X = min(screenCoord[0].X, cornerCoord.X);
				screenCoord[0].Y = min(screenCoord[0].Y, cornerCoord.Y);
				screenCoord[1].X = max(screenCoord[1].X, cornerCoord.X);
				screenCoord[1].Y = max(screenCoord[1].Y, cornerCoord.Y);
			}
		}
		
		let texSize = TexMan.GetScaledSize(BracketTex) * (min(Screen.GetWidth(), Screen.GetHeight()) / ScaleBase);
		
		// Make sure the brackets don't overlap.
		{
			let centerCoord = screenCoord[0] + ((screenCoord[1] - screenCoord[0]) * .5);
			screenCoord[0].X = min(screenCoord[0].X, centerCoord.X - texSize.X);
			screenCoord[0].Y = min(screenCoord[0].Y, centerCoord.Y - texSize.Y);
			screenCoord[1].X = max(screenCoord[1].X, centerCoord.X + texSize.X);
			screenCoord[1].Y = max(screenCoord[1].Y, centerCoord.Y + texSize.Y);
		}
		
		for (let corner = 0; corner < 4; corner++) {
			Screen.DrawTexture(
				BracketTex, false,
				screenCoord[corner & 1].X - (corner & 1? texSize.X : 0.),
				// (2 & 2) = 2, but we need 0 or 1. !! gives us that.
				screenCoord[!!(corner & 2)].Y - (corner & 2? texSize.Y : 0),
				DTA_Alpha, Opacity,
				DTA_FlipX, corner & 1,
				DTA_FlipY, !!(corner & 2),
				DTA_DestWidthF, texSize.X,
				DTA_DestHeightF, texSize.Y
			);
		}
		
		let fontHeight = dc.MsgFont.GetHeight() * CleanYFac;
		
		Vector2 textCoord = (
			screenCoord[0].X,
			screenCoord[1].Y + (fontHeight * .8)
		);
		
		Screen.DrawText(
			dc.MsgFont, TextColor_Description,
			textCoord.X, textCoord.Y,
			TargetTag,
			DTA_TextLen, int(TargetTag.Length() * Opacity),
			DTA_Alpha, Opacity,
			DTA_CleanNoMove, true
		);
		
		textCoord.Y += fontHeight * 1.8;
		
		{
			// Draw the label saying which button to push.
			String keyName;
			{
				int bindingKeys[2];
				[bindingKeys[0], bindingKeys[1]] = Bindings.GetKeysForCommand("+use");
				keyName = KeyBindings.NameKeys(bindingKeys[0], bindingKeys[1]);
			}
			let keyNameWidth = dc.MsgFont.StringWidth(keyName) * CleanXFac;
			let borderWidth = max(fontHeight >> 2, 1);
			
			Screen.Dim(
				BackgroundColor_KeyBind,
				opacity,
				textCoord.X - borderWidth,
				textCoord.Y - borderWidth,
				keyNameWidth + borderWidth + borderWidth,
				fontHeight + borderWidth + borderWidth
			);
			
			Screen.DrawText(
				dc.MsgFont, TextColor_KeyBind,
				textCoord.X, textCoord.Y,
				keyName,
				DTA_Alpha, opacity,
				DTA_CleanNoMove, true
			);
			
			// Advance the draw position for the text.
			textCoord.X += keyNameWidth + borderWidth + borderWidth + dc.MsgFont.GetCharWidth(20) * 2;
		}
		
		// Draw the “pick up” label.
		Screen.DrawText(
			dc.MsgFont, TextColor_PressToUseMsg,
			textCoord.X, textCoord.Y,
			"$U2P_PickUpText",
			DTA_TextLen, int(TargetTag.Length() * Opacity),
			DTA_Alpha, Opacity,
			DTA_CleanNoMove, true
		);
	}
}

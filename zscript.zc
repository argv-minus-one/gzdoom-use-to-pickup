Version "3.4"

// See https://gitlab.com/Gutawer/gzdoom-gutamatics/
#include "U2P_Gutamatics/Include.zsc"

class UseToPickup : StaticEventHandler {
	U2P_PlayerState PlayerStates[MAXPLAYERS];
	Font MsgFont;
	private ThinkerIterator Drawables;
	
	override void OnRegister() {
		MsgFont = Font.FindFont('SMALLFONT');
		Drawables = ThinkerIterator.Create('U2P_ItemHighlight');
	}
	
	override void PlayerEntered(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (!PlayerStates[p])
			PlayerStates[p] = new("U2P_PlayerState");
		PlayerStates[p].Init(players[p]);
	}
	
	override void PlayerRespawned(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (PlayerStates[p])
			PlayerStates[p].ClearFocus();
	}
	
	override void PlayerDisconnected(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (PlayerStates[p]) {
			PlayerStates[p].Destroy();
			PlayerStates[p] = null;
		}
	}
	
	override void RenderOverlay(RenderEvent evt) {
		if (automapactive || !playeringame[consoleplayer])
			return;
		
		U2P_DrawContext dc;
		dc.MsgFont = MsgFont;
		dc.InitFromRenderEvent(evt);
		
		Drawables.Reinit();
		for (let drawable = Drawables.Next(); drawable; drawable = Drawables.Next())
			U2P_ItemHighlight(drawable).Draw(dc);
	}
}

struct U2P_DrawContext ui {
	Actor Viewer;
	Vector3 ViewPos, ViewAngles;
	U2P_Matrix WorldToClip;
	double FracTic;
	float ViewerFOV;
	Font MsgFont;
	
	void InitFromRenderEvent(RenderEvent evt) {
		Viewer = evt.Camera;
		ViewPos = evt.ViewPos;
		ViewAngles = (evt.ViewAngle, evt.ViewPitch, evt.ViewRoll);
		FracTic = evt.FracTic;
		ViewerFOV = players[consoleplayer].FOV;
		Init();
	}
	
	// This needs to be called *after* ViewPos, ViewAngles, and ViewerFOV are set.
	void Init() {
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		WorldToClip = U2P_Matrix.worldToClip(ViewPos, ViewAngles.X, ViewAngles.Y, ViewAngles.Z, ViewerFOV);
	}
}

class U2P_PlayerState : Thinker {
	const ItemsCompactSize = 3;
	const HighlightFOV = 40.;
	
	U2P_ItemHighlight FocusedItem;
	PlayerInfo Player;
	transient bool IsEnabled;
	transient CVar IsEnabledCVar;
	
	U2P_PlayerState Init(PlayerInfo player) {
		self.Player = player;
		return self;
	}
	
	void ClearFocus() {
		if (FocusedItem) {
			FocusedItem.FadeOut();
			FocusedItem = null;
		}
	}
	
	override void Tick() {
		// Clear the focused item, if appropriate.
		if (FocusedItem && !FocusedItem.Target)
			FocusedItem = null;
		
		// Update enabled status, PICKUP flag, etc.
		if (!IsEnabledCVar)
			IsEnabledCVar = CVar.GetCVar('usetopickup_enabled', Player);
		
		let pp = Player.mo;
		if (IsEnabledCVar.GetBool()) {
			IsEnabled = true;
			if (pp)
				pp.bPickup = false;
		}
		else if (IsEnabled) {
			IsEnabled = false;
			if (pp)
				pp.bPickup = GetDefaultByType(pp.GetClass()).bPickup;
			ClearFocus();
		}
		
		if (pp && IsEnabled && !(gametic & 3)) {
			// How far away can this actor pick up items from?
			double range;
			if (usetopickup_fulluserange && pp is "PlayerPawn")
				range = PlayerPawn(pp).UseRange;
			else {
				// TODO: Just check if the actor is touching?
				let pitchVec = Actor.AngleToVector(pp.Pitch);
				range = pp.Radius * abs(pitchVec.X) + pp.Height * abs(pitchVec.Y);
			}
			
			Inventory origTarget = null, bestTarget = null;
			double bestDFC = HighlightFOV;
			bool valid;
			
			// Check the current focused item.
			if (FocusedItem) {
				origTarget = FocusedItem.Target;
				if (IsBetterTarget(pp, origTarget, range, bestDFC))
					bestTarget = origTarget;
			}
			
			// Look for the item that's closest to the center of the player actor's field of view.
			for (let i = BlockThingsIterator.Create(pp, range); i.Next();)
			if (i.thing != bestTarget && i.thing is "Inventory" && i.thing.bSpecial && IsBetterTarget(pp, i.thing, range, bestDFC))
				bestTarget = Inventory(i.thing);
			
			if (FocusedItem && (!bestTarget || bestTarget != origTarget)) {
				// We're now focusing on something other than what's currently focused (either nothing or a different actor), so clear the current focus.
				ClearFocus();
			}
			
			if (bestTarget && bestTarget != origTarget)
				// Got a new target to focus on.
				FocusedItem = new("U2P_ItemHighlight").Init(Player, bestTarget);
		}
		
		// Check if the player is allowed to pick up the focused item.
		if (
			IsEnabled &&
			pp &&
			FocusedItem &&
			FocusedItem.Target &&
			FocusedItem.Ready
		) {
			// If so, then block the usual effects of the use button.
			Player.usedown = true;
			
			// Check if the player wants to pick up the item.
			if (
				(Player.cmd.buttons & BT_USE) &&
				!(Player.oldbuttons & BT_USE)
			)
				FocusedItem.Target.Touch(pp);
		}
	}
	
	/**
	 * Checks whether a target is valid, and if so, updates bestDFC.
	 *
	 * The target is valid if:
	 * • It is within the given range of the viewer.
	 * • Its distance from the center of the viewer's field of view (that is, how far the viewer would need to look left/right/up/down to look straight at the target) is less than bestDFC.
	 *
	 * @param viewer The viewing actor.
	 * @param target The actor that may or may not be a valid target.
	 * @param range How far away the target may be.
	 * @param bestDFC Distance-from-center of currently focused target. This is an out parameter; if the given target is valid, bestDFC will be updated with the DFC of the given target.
	 * @return true if the target is valid; false otherwise.
	 */
	static bool IsBetterTarget(Actor viewer, Actor target, double range, in out double bestDFC) {
		if (
			// Does it exist at all?
			!target ||
			// Is it in range?
			viewer.Distance3D(target) > range
		)
			// Nope.
			return false;
		
		let vecTo = viewer.Vec3To(target);
		
		// Correct for the center of target, and the view height of viewer.
		vecTo.Z += target.Height / 2.;
		vecTo.Z -= viewer.player? viewer.player.viewheight : viewer.Height / 2;
		
		let dirTo = vecTo.Unit();
		Vector2 viewDA = (
			Actor.deltaangle(viewer.AngleTo(target), viewer.Angle),
			Actor.deltaangle(-asin(dirTo.Z), viewer.Pitch)
		);
		let dfc = viewDA.Length();
		
		// Is it within acceptable angles?
		if (dfc < bestDFC) {
			bestDFC = dfc;
			return true;
		}
		else
			return false;
	}
}

class U2P_ItemHighlight : Thinker {
	const FadeInRate = float(.14);
	const FadeOutRate = float(-.07);
	const FullOpacity = float(1.);
	
	Inventory Target;
	PlayerInfo Player;
	float Opacity;
	protected float OpacityIncrement;
	bool Ready;
	
	// Record this information so that the highlight can fade out, even if the item disappears.
	Vector3 TargetPos;
	double TargetHeight, TargetRadius;
	String TargetTag;
	
	U2P_ItemHighlight Init(PlayerInfo player, Inventory target) {
		self.Player = player;
		self.Target = target;
		OpacityIncrement = FadeInRate;
		return self;
	}
	
	override void Tick() {
		if (!Player) {
			Destroy();
			return;
		}
		
		switch (Player.playerstate) {
			case PST_DEAD:
			case PST_REBORN:
				// If player is dead, fade out.
				Target = null;
				break;
			
			case PST_ENTER:
			case PST_GONE:
				// If player isn't present at all, then this object is no longer valid, so bail.
				Destroy();
				return;
			
			// Otherwise, carry on.
		}
		
		if (Target) {
			TargetPos = Target.Pos;
			TargetTag = Target.GetTag(Target.GetClassName());
			TargetHeight = Target.Height;
			TargetRadius = Target.Radius;
		}
		else {
			// Target lost. Fade out.
			FadeOut();
		}
		
		if (OpacityIncrement)
			Opacity = clamp(Opacity + OpacityIncrement, 0., FullOpacity);
		
		if (Opacity == 0.) {
			// Fully faded out.
			Destroy();
			return;
		}
		
		Ready = Opacity == FullOpacity;
		if (Ready)
			// Fully visible.
			OpacityIncrement = 0;
	}
	
	void FadeOut() {
		if (OpacityIncrement >= 0.)
			OpacityIncrement = FadeOutRate;
	}
	
	const TextColor_Description = Font.CR_WHITE;
	const TextColor_KeyBind = Font.CR_GRAY;
	const TextColor_PressToUseMsg = Font.CR_WHITE;
	const BackgroundColor_KeyBind = Color(0xffffffe6);
	const BracketColor = Color(0xffffffff);
	const BracketTexName = "UseToPickup/bracket.png";
	private transient ui TextureID BracketTex;
	
	// Scale the brackets such that they're drawn 1:1 on a screen whose min(width,height) is this many pixels.
	const ScaleBase = 4000.;
	
	ui void Draw(U2P_DrawContext dc) {
		// Don't actually draw anything for anyone other than the console player.
		// Note that these highlighters have playsim effects too, so they still exist for other players; they just aren't drawn.
		if (Player != players[consoleplayer])
			return;
		
		switch (Player.playerstate) {
			case PST_ENTER:
			case PST_GONE:
				// Similarly, if the owning player isn't in the game, don't draw anything.
				return;
		}
		
		// Look up the bracket texture, if needed.
		if (!BracketTex.IsValid()) {
			BracketTex = TexMan.CheckForTexture(BracketTexName, TexMan.Type_Any);
			if (!BracketTex.IsValid())
				ThrowAbortException("%s can't find required texture %s!", GetClassName(), BracketTexName);
		}
		
		// Top left, bottom right
		Vector2 screenCoord[2];
		
		// Adapted from Pixel Eater's Fill Spectre.
		for (let corner = 0; corner < 4; corner++) {
			// Compute one corner at a time.
			// The corner numbers are: 0 = top left, 1 = top right, 2 = bottom left, 3 = bottom right
			let vert = dc.ViewPos + LevelLocals.Vec3Diff(
				dc.ViewPos,
				TargetPos + (
					// `corner & 1` is only true for the top right and bottom right corners.
					sin(dc.Viewer.Angle) * TargetRadius * (corner & 1? 1. : -1.),
					cos(dc.Viewer.Angle) * TargetRadius * (corner & 1? -1. : 1.),
					// `corner & 2` is only true for the bottom left and bottom right corners.
					corner & 2? 0 : TargetHeight
				)
			);
			
			let ndc = dc.WorldToClip.multiplyVector3(vert).asVector3();
			
			if (ndc.Z > 1. || ndc.Z < -1.)
				// Out of camera view. Don't draw anything.
				// This is the reason why we store all four coordinates in the screenCoord and then loop over them again: if *any* of the coordinates are out of view, we need to not draw anything!
				return;
			
			let cornerCoord = U2P_GlobalMaths.ndcToViewPort(ndc);
			
			// That projects the corners of the sprite on the screen. Now, make a rectangle from the coordinates.
			if (!corner) {
				// For the first corner, just use that coordinate to start.
				screenCoord[0] = screenCoord[1] = cornerCoord;
			}
			else {
				// From there, stretch out the rectangle to fit the thing.
				screenCoord[0].X = min(screenCoord[0].X, cornerCoord.X);
				screenCoord[0].Y = min(screenCoord[0].Y, cornerCoord.Y);
				screenCoord[1].X = max(screenCoord[1].X, cornerCoord.X);
				screenCoord[1].Y = max(screenCoord[1].Y, cornerCoord.Y);
			}
		}
		
		let texSize = TexMan.GetScaledSize(BracketTex) * (min(Screen.GetWidth(), Screen.GetHeight()) / ScaleBase);
		
		// Make sure the brackets don't overlap.
		{
			let centerCoord = screenCoord[0] + ((screenCoord[1] - screenCoord[0]) * .5);
			screenCoord[0].X = min(screenCoord[0].X, centerCoord.X - texSize.X);
			screenCoord[0].Y = min(screenCoord[0].Y, centerCoord.Y - texSize.Y);
			screenCoord[1].X = max(screenCoord[1].X, centerCoord.X + texSize.X);
			screenCoord[1].Y = max(screenCoord[1].Y, centerCoord.Y + texSize.Y);
		}
		
		for (let corner = 0; corner < 4; corner++) {
			Screen.DrawTexture(
				BracketTex, false,
				screenCoord[corner & 1].X - (corner & 1? texSize.X : 0.),
				// (2 & 2) = 2, but we need 0 or 1. !! gives us that.
				screenCoord[!!(corner & 2)].Y - (corner & 2? texSize.Y : 0),
				DTA_Alpha, Opacity,
				DTA_FlipX, corner & 1,
				DTA_FlipY, !!(corner & 2),
				DTA_DestWidthF, texSize.X,
				DTA_DestHeightF, texSize.Y
			);
		}
	}
}

Version "3.4"

// See https://gitlab.com/Gutawer/gzdoom-gutamatics/
#include "U2P_Gutamatics/Include.zsc"

class UseToPickup : StaticEventHandler {
	U2P_PlayerState PlayerStates[MAXPLAYERS];
	Font MsgFont;
	
	override void OnRegister() {
		MsgFont = Font.FindFont('SMALLFONT');
	}
	
	override void WorldTick() {
		for (let p = 0; p < MAXPLAYERS; p++)
		if (playeringame[p]) {
			PlayerStates[p].Tick();
			
			let pp = players[p].mo;
			if (!pp || pp.Health <= 0) {
				PlayerStates[p].FadeOutAll();
				continue;
			}
		}
	}
	
	override void PlayerEntered(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		PlayerStates[p].Init(players[p]);
	}
	
	override void PlayerRespawned(PlayerEvent evt) {
		PlayerStates[evt.PlayerNumber].Clear();
	}
	
	override void PlayerDisconnected(PlayerEvent evt) {
		PlayerStates[evt.PlayerNumber].Clear(hard: true);
	}
	
	override void RenderOverlay(RenderEvent evt) {
		if (automapactive || !playeringame[consoleplayer])
			return;
		
		U2P_DrawContext dc;
		dc.MsgFont = MsgFont;
		dc.InitFromRenderEvent(evt);
		PlayerStates[consoleplayer].Draw(dc);
	}
}

struct U2P_DrawContext ui {
	Actor Viewer;
	Vector3 ViewPos, ViewAngles;
	U2P_Matrix WorldToClip;
	double FracTic;
	float ViewerFOV;
	Font MsgFont;
	
	void InitFromRenderEvent(RenderEvent evt) {
		Viewer = evt.Camera;
		ViewPos = evt.ViewPos;
		ViewAngles = (evt.ViewAngle, evt.ViewPitch, evt.ViewRoll);
		FracTic = evt.FracTic;
		ViewerFOV = players[consoleplayer].FOV;
		Init();
	}
	
	// This needs to be called *after* ViewPos, ViewAngles, and ViewerFOV are set.
	void Init() {
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		WorldToClip = U2P_Matrix.worldToClip(ViewPos, ViewAngles.X, ViewAngles.Y, ViewAngles.Z, ViewerFOV);
	}
}

struct U2P_PlayerState play {
	const ItemsCompactSize = 3;
	
	Array<U2P_ItemHighlight> Items;
	U2P_ItemHighlight FocusedItem;
	PlayerInfo Player;
	bool IsEnabled;
	CVar IsEnabledCVar;
	
	void Clear(bool hard = false) {
		IsEnabled = false;
		IsEnabledCVar = null;
		
		if (hard) {
			Items.Clear();
			Items.ShrinkToFit();
		}
		else {
			Items.Resize(min(Items.Size(), ItemsCompactSize));
			
			for (let i = 0, s = Items.Size(); i < s; i++)
			if (Items[i])
				Items[i].Clear();
		}
	}
	
	void FadeOutAll() {
		for (let i = 0, s = Items.Size(); i < s; i++)
		if (Items[i])
			Items[i].Target = null;
	}
	
	void Init(PlayerInfo p) {
		Clear();
		Player = p;
		IsEnabledCVar = CVar.GetCVar('usetopickup_enabled', p);
	}
	
	void Tick() {
		// Periodically clean up excess highlighters, to save memory.
		if (!(gametic & 1023))
		for (uint s = Items.Size(), i = s - 1; i >= 0; i--)
		if (!Items[i] || (!Items[i].InUse && s > ItemsCompactSize)) {
			Items.Delete(i);
			s--;
		}
		
		// Tick (remaining) highlighters that are in use.
		for (uint i = 0, s = Items.Size(); i < s; i++)
		if (Items[i])
			Items[i].Tick();
		
		// Clear the focused item, if appropriate.
		if (FocusedItem && (!FocusedItem.InUse || !FocusedItem.Target))
			FocusedItem = null;
		
		// Update enabled status, PICKUP flag, etc.
		let pp = Player.mo;
		if (!IsEnabledCVar || IsEnabledCVar.GetBool()) {
			IsEnabled = true;
			if (pp)
				pp.bPickup = false;
		}
		else if (IsEnabled) {
			IsEnabled = false;
			if (pp)
				pp.bPickup = GetDefaultByType(pp.GetClass()).bPickup;
			FocusedItem = null;
			FadeOutAll();
		}
		
		if (pp && IsEnabled && !(gametic & 3)) {
			// How far away can this actor pick up items from?
			double range;
			if (usetopickup_fulluserange && pp is "PlayerPawn")
				range = PlayerPawn(pp).UseRange;
			else {
				// TODO: Just check if the actor is touching?
				let pitchVec = Actor.AngleToVector(pp.Pitch);
				range = pp.Radius * abs(pitchVec.X) + pp.Height * abs(pitchVec.Y);
			}
			
			// Look for the item that's closest to the center of the player actor's field of view.
			Inventory origTarget = FocusedItem? FocusedItem.Target : null, bestTarget = origTarget;
			double bestViewDA = origTarget? ViewDAL(pp, origTarget) : 180;
			
			for (let i = BlockThingsIterator.Create(pp, range); i.Next();)
			if (i.thing != bestTarget && i.thing is "Inventory" && i.thing.bSpecial) {
				let da = ViewDAL(pp, i.thing);
				if (da < bestViewDA /*&& pp.IsVisible(i.thing, true)*/) {
					bestViewDA = da;
					bestTarget = Inventory(i.thing);
				}
			}
			
			if (FocusedItem && (bestViewDA >= 70. || !bestTarget || bestTarget != origTarget)) {
				// If all items are really far from the center of the player's view, there aren't any in range at all, or we're switching focus targets, then we need to defocus the current FocusedItem.
				FocusedItem.Target = null;
				FocusedItem = null;
			}
			
			if (bestViewDA < 70. && bestTarget && !FocusedItem) {
				// Got a new target to focus on.
				// Find a free slot in the Items array, if any. Otherwise, allocate a new one.
				uint i = 0, s = Items.Size();
				
				for (; i < s; i++)
				if (!Items[i] || !Items[i].InUse)
					break;
				
				if (i == s) {
					// We've run out of available slots.
					FocusedItem = new("U2P_ItemHighlight");
					let slot = Items.Push(FocusedItem);
				}
				else if (!Items[i]) {
					// Found a null slot. Fill it.
					FocusedItem = new("U2P_ItemHighlight");
					Items[i] = FocusedItem;
				}
				else
					// Found an existing, filled but unused slot.
					FocusedItem = Items[i];
				
				// In any case, set it up.
				FocusedItem.Target = bestTarget;
				FocusedItem.Tick();
			}
		}
		
		// Check if the player wants and is allowed to pick up the focused item.
		if (
			IsEnabled &&
			pp &&
			(Player.cmd.buttons & BT_USE) &&
			!Player.usedown &&
			FocusedItem &&
			FocusedItem.Target &&
			FocusedItem.Opacity == 1.
		) {
			FocusedItem.Target.Touch(pp);
		}
	}
	
	// Computes how far the center of `to` is from the center of `from`'s field of view.
	static double ViewDAL(Actor from, Actor to) {
		let vecTo = from.Vec3To(to);
		
		// Correct for the center of to, and the view height of from.
		vecTo.Z += to.Height / 2.;
		vecTo.Z -= from.player? from.player.viewheight : from.Height / 2;
		
		let dirTo = vecTo.Unit();
		Vector2 vda = (
			Actor.deltaangle(from.AngleTo(to), from.Angle),
			Actor.deltaangle(-asin(dirTo.Z), from.Pitch)
		);
		return vda.Length();
	}
	
	ui void Draw(U2P_DrawContext dc) const {
		for (uint i = 0, s = Items.Size(); i < s; i++)
		if (Items[i] && Items[i].InUse)
			Items[i].Draw(dc);
	}
}

class U2P_ItemHighlight {
	const FadeInRate = float(.14);
	const FadeOutRate = float(-.07);
	
	Inventory Target;
	float Opacity;
	protected float OpacityIncrement;
	bool InUse, Ready;
	
	// Record this information so that the highlight can fade out, even if the item disappears.
	Vector3 TargetPos;
	double TargetHeight, TargetRadius;
	String TargetTag;
	
	void Clear() {
		Ready = InUse = false;
		Target = null;
		TargetTag = "";
		OpacityIncrement = Opacity = 0;
	}
	
	play void Tick() {
		if (Target) {
			if (Opacity < 1.)
				OpacityIncrement = FadeInRate;
			
			TargetPos = Target.Pos;
			TargetTag = Target.GetTag(Target.GetClassName());
			TargetHeight = Target.Height;
			TargetRadius = Target.Radius;
		}
		else {
			if (Opacity > 0.)
				OpacityIncrement = FadeOutRate;
		}
		
		if (OpacityIncrement)
			Opacity = clamp(Opacity + OpacityIncrement, 0., 1.);
		
		if (InUse && Opacity == 0. && !Target)
			Clear();
		else {
			InUse = Target || Opacity > 0.;
			Ready = Target && Opacity == 1.;
			
			if (Ready)
				OpacityIncrement = 0;
		}
	}
	
	const TextColor_Description = Font.CR_WHITE;
	const TextColor_KeyBind = Font.CR_GRAY;
	const TextColor_PressToUseMsg = Font.CR_WHITE;
	const BackgroundColor_KeyBind = Color(0xffffffe6);
	
	ui void Draw(U2P_DrawContext dc) const {
		if (!InUse)
			return;
		
		let itemRelPos = dc.ViewPos + LevelLocals.Vec3Diff(dc.ViewPos, TargetPos);
		
		let itemTopLeft = U2P_GlobalMaths.ndcToViewPort(
			dc.WorldToClip.multiplyVector3(itemRelPos + (0, 0, TargetHeight)).asVector3()
		);
		
		let itemBottomRight = U2P_GlobalMaths.ndcToViewPort(
			dc.WorldToClip.multiplyVector3(itemRelPos).asVector3()
		);
		
		Screen.DrawLine(itemTopLeft.X, itemTopLeft.Y, itemBottomRight.X, itemBottomRight.Y, 0xff00ffff);
		
		int origin[2];
		origin[0] = Screen.GetWidth() >> 4;
		origin[1] = Screen.GetHeight() >> 2;
		let fontHeight = dc.MsgFont.GetHeight() * CleanYFac;
		
		Screen.DrawText(
			dc.MsgFont, TextColor_Description,
			origin[0], origin[1],
			TargetTag,
			DTA_Alpha, Opacity,
			DTA_CleanNoMove, true
		);
		
		origin[1] += fontHeight * 9 / 5;
		
		String keyName;
		{
			int bindingKeys[2];
			[bindingKeys[0], bindingKeys[1]] = Bindings.GetKeysForCommand("+use");
			keyName = KeyBindings.NameKeys(bindingKeys[0], bindingKeys[1]);
		}
		let keyNameWidth = dc.MsgFont.StringWidth(keyName) * CleanXFac;
		let borderWidth = max(fontHeight >> 2, 1);
		
		Screen.Dim(
			BackgroundColor_KeyBind,
			Opacity,
			origin[0] - borderWidth,
			origin[1] - borderWidth,
			keyNameWidth + borderWidth + borderWidth,
			fontHeight + borderWidth + borderWidth
		);
		
		Screen.DrawText(
			dc.MsgFont, TextColor_KeyBind,
			origin[0], origin[1],
			keyName,
			DTA_Alpha, Opacity,
			DTA_CleanNoMove, true
		);
		
		origin[0] += keyNameWidth + (fontHeight >> 1);
		
		Screen.DrawText(
			dc.MsgFont, TextColor_PressToUseMsg,
			origin[0], origin[1],
			"Pick up",
			DTA_Alpha, Opacity,
			DTA_CleanNoMove, true
		);
	}
}

Version "3.4"

#include "UseToPickup/INIFile.zc"
// See https://gitlab.com/Gutawer/gzdoom-gutamatics/
#include "U2P_Gutamatics/Include.zsc"

class UseToPickup : StaticEventHandler {
	U2P_PlayerState PlayerStates[MAXPLAYERS];
	Font MsgFont;
	private ThinkerIterator Drawables;
	private Array<U2P_ActorClassInfo> ClassInfo;
	
	override void OnRegister() {
		MsgFont = Font.FindFont('SMALLFONT');
		Drawables = ThinkerIterator.Create('U2P_ItemHighlight');
		
		ClassInfo.Clear();
		
		U2P_INIFile ini;
		ini.ReadLumpsNamed("UseToPickup.ini");
		ini.MergeByActorClass();
		
		for (let aci = 0, acs = AllActorClasses.Size(); aci < acs; aci++) {
			let ac = AllActorClasses[aci];
			let sec = ini.Section(ac.GetClassName());
			if (!sec)
				continue;
			
			let ci = new("U2P_ActorClassInfo");
			ci.ActorClass = ac;
			ci.Init(sec);
			ClassInfo.Push(ci);
		}
	}
	
	override void WorldLoaded(WorldEvent evt) {
		// This is a StaticEventHandler. It is initialized only on engine startup, and its state is not part of save files. This is useful because it fills in the ClassInfo on engine startup only, but it has the side effect that the PlayerStates array is lost when loading a save! So, we'll iterate over all live U2P_PlayerState instances, and reconstruct our PlayerStates array from that.
		
		// But first, we need to clear it out of stale references.
		for (let i = 0; i < MAXPLAYERS; i++)
			PlayerStates[i] = null;
		
		let i = ThinkerIterator.Create('U2P_PlayerState');
		U2P_PlayerState ps;
		while (ps = U2P_PlayerState(i.Next())) {
			let p = ps.PlayerNum;
			
			if (PlayerStates[p]) {
				Console.Printf("\cgMultiple U2P_PlayerState instances for player number %d! Deleting one of them.", p);
				ps.Destroy();
			}
			else
				PlayerStates[p] = ps;
		}
	}
	
	override void PlayerEntered(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		
		// Don't apply to bots.
		if (players[p].bot)
			return;
		
		if (!PlayerStates[p])
			PlayerStates[p] = new("U2P_PlayerState");
		PlayerStates[p].Init(players[p], p);
	}
	
	override void PlayerRespawned(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (PlayerStates[p])
			PlayerStates[p].ClearFocus();
	}
	
	override void PlayerDisconnected(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		if (PlayerStates[p]) {
			PlayerStates[p].Destroy();
			PlayerStates[p] = null;
		}
	}
	
	override void RenderOverlay(RenderEvent evt) {
		if (automapactive || !playeringame[consoleplayer])
			return;
		
		U2P_DrawContext dc;
		dc.MsgFont = MsgFont;
		dc.InitFromRenderEvent(evt);
		
		Drawables.Reinit();
		for (let drawable = Drawables.Next(); drawable; drawable = Drawables.Next())
			U2P_ItemHighlight(drawable).Draw(dc);
	}
	
	static clearscope U2P_ActorClassInfo ActorClassInfo(Class<Actor> actorClass) {
		let o = UseToPickup(StaticEventHandler.Find('UseToPickup'));
		
		for (let idx = 0, size = o.ClassInfo.Size(); idx < size; idx++) {
			let ci = o.ClassInfo[idx];
			if (ci.ActorClass == actorClass)
				return ci;
		}
		
		return null;
	}
	
	override void NetworkProcess(ConsoleEvent evt) {
		if (evt.Name == "UseToPickup_Push") {
			let ps = PlayerStates[evt.Player];
			if (!ps)
				ThrowAbortException("Netevent UseToPickup_Push from nonexistent player %d!", evt.Player);
			ps.PushFocusedItem();
		}
	}
	
	static const Name CVarNames[] = {
		'usetopickup_enabled',
		'usetopickup_highlight_color',
		'usetopickup_highlight_opacity',
		'usetopickup_fadeintime',
		'usetopickup_fadeouttime',
		'usetopickup_fulluserange'
	};
	
	override void ConsoleProcess(ConsoleEvent evt) {
		if (evt.Name == "UseToPickup_ResetAllCVars")
		for (let i = 0, s = CVarNames.Size(); i < s; i++)
			CVar.FindCVar(CVarNames[i]).ResetToDefault();
	}
}

class U2P_ActorClassInfo {
	Class<Actor> ActorClass;
	String Tag;
	bool AlwaysTouchPickup, ForceTag, UsePickupMessageAsTag, UseSpriteDimensions, OverrideRadius, OverrideHeight, OverrideZOffset;
	double Radius, Height, ZOffset;
	
	void Init(U2P_INISection section) {
		Tag = section.Get("Tag");
		AlwaysTouchPickup = section.GetBool("AlwaysTouchPickup");
		ForceTag = section.GetBool("ForceTag");
		UsePickupMessageAsTag = section.GetBool("UsePickupMessageAsTag");
		UseSpriteDimensions = section.GetBool("UseSpriteDimensions", default: true);
		Radius = section.GetDouble("Radius", default: double.NaN);
		Height = section.GetDouble("Height", default: double.NaN);
		ZOffset = section.GetDouble("ZOffset", default: double.NaN);
		
		// This is a fun little trick. Unlike all other floating-point values, NaN does *not* equal itself, so we can detect whether a value is NaN by comparing it to itself.
		OverrideRadius = Radius == Radius;
		OverrideHeight = Height == Height;
		OverrideZOffset = ZOffset == ZOffset;
	}
}

struct U2P_DrawContext ui {
	Actor Viewer;
	Vector3 ViewPos, ViewAngles;
	U2P_Matrix WorldToClip;
	double FracTic;
	float ViewerFOV;
	Font MsgFont;
	
	void InitFromRenderEvent(RenderEvent evt) {
		Viewer = evt.Camera;
		ViewPos = evt.ViewPos;
		ViewAngles = (evt.ViewAngle, evt.ViewPitch, evt.ViewRoll);
		FracTic = evt.FracTic;
		ViewerFOV = players[consoleplayer].FOV;
		Init();
	}
	
	// This needs to be called *after* ViewPos, ViewAngles, and ViewerFOV are set.
	void Init() {
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		WorldToClip = U2P_Matrix.worldToClip(ViewPos, ViewAngles.X, ViewAngles.Y, ViewAngles.Z, ViewerFOV);
	}
}

class U2P_ItemReachabilityTracer : LineTracer {
	Array<Actor> IgnoreActors;
	
	override ETraceStatus TraceCallback() {
		switch (Results.HitType) {
			case TRACE_HitFloor:
			case TRACE_HitCeiling:
				return TRACE_Stop;
			
			case TRACE_HitActor:
				if (Results.HitActor.bShootable && IgnoreActors.Find(Results.HitActor) == IgnoreActors.Size())
					return TRACE_Stop;
				else
					break;
			
			case TRACE_HitWall:
				if (Results.HitLine.flags & (Line.ML_BLOCKEVERYTHING | Line.ML_BLOCKUSE) || Results.Tier != TIER_Middle)
					return TRACE_Stop;
		}
		
		return TRACE_Skip;
	}
}

// There should always be exactly one instance of this class for every instance of U2P_PlayerState.
// It's a separate class because CVars, and therefore U2P_PlayerSettings, have a different lifecycle (they aren't saved, and are reinitialized on loading a save) than U2P_PlayerState (which is saved).
class U2P_PlayerSettings {
	CVar IsEnabled, HighlightColor, HighlightOpacity, FadeInTime, FadeOutTime;
	
	U2P_PlayerSettings Init(PlayerInfo player) {
		IsEnabled = CVar.GetCVar('usetopickup_enabled', Player);
		HighlightColor = CVar.GetCVar('usetopickup_highlight_color', Player);
		HighlightOpacity = CVar.GetCVar('usetopickup_highlight_opacity', Player);
		FadeInTime = CVar.GetCVar('usetopickup_fadeintime', Player);
		FadeOutTime = CVar.GetCVar('usetopickup_fadeouttime', Player);
		return self;
	}
}

class U2P_PlayerState : Thinker {
	const HighlightFOV = 25.;
	const PushCooldownTics = 15;
	
	U2P_ItemHighlight FocusedItem;
	PlayerInfo Player;
	int PlayerNum;
	uint8 SelectPhase;
	transient U2P_PlayerSettings Settings;
	transient private uint8 PushCooldown;
	
	U2P_PlayerState Init(PlayerInfo player, int playerNum) {
		// Tick before U2P_ItemHighlight does.
		ChangeStatNum(STAT_USER);
		
		self.Player = player;
		self.PlayerNum = playerNum;
		
		// Target selection runs every 4 tics. In multiplayer with a lot of players, this could result in stuttering, from target selection happening for all of them at the same time (every fourth tic). So, we offset which of every fourth tic to perform target selection on, based on the player number. For example:
		// Player 0 will select targets on tic 0, 3, 6, …
		// Player 1 will select targets on tic 1, 4, 7, …
		// Player 2 will select targets on tic 2, 5, 8, …
		// Player 4 will select targets on tic 0, 3, 6, …
		// Player 5 will select targets on tic 1, 4, 7, …
		SelectPhase = playerNum & 3;
		
		return self;
	}
	
	void ClearFocus() {
		if (FocusedItem) {
			FocusedItem.FadeOut();
			FocusedItem = null;
		}
	}
	
	override void OnDestroy() {
		if (FocusedItem)
			FocusedItem.Destroy();
	}
	
	void PushFocusedItem() {
		if (PushCooldown || !FocusedItem)
			return;
		
		let item = FocusedItem.Target;
		if (!item || !item.bSpecial)
			return;
		
		let pp = Player.mo;
		if (!pp)
			return;
		
		item.Thrust(1, pp.AngleTo(item));
		PushCooldown = PushCooldownTics;
	}
	
	override void Tick() {
		if (!Settings)
			Settings = new('U2P_PlayerSettings').Init(Player);
		
		if (Player.playerstate != PST_LIVE || Player.bot) {
			// For dead players (and bots, if a regular player somehow becomes a bot), just clear everything out.
			ClearFocus();
			PushCooldown = 0;
			if (Player.mo)
				Player.mo.bPickup = GetDefaultByType(Player.mo.GetClass()).bPickup;
			return;
		}
		
		// Clear the focused item, if appropriate.
		if (FocusedItem && !FocusedItem.Target)
			FocusedItem = null;
		
		if (PushCooldown)
			PushCooldown--;
		
		let pp = Player.mo;
		let enabled = Settings.IsEnabled.GetBool();
		
		// Block normal pickup, if appropriate.
		if (pp)
			pp.bPickup = enabled? false : GetDefaultByType(pp.GetClass()).bPickup;
		
		// Clear the focused item, if appropriate.
		if (!enabled || (FocusedItem && (!FocusedItem.Target || !FocusedItem.Target.bSpecial)))
			ClearFocus();
		
		if (pp && enabled && !((gametic + SelectPhase) & 3)) {
			Inventory origTarget = null, bestTarget = null;
			U2P_ActorClassInfo bestTargetCI = null;
			double bestDFC = HighlightFOV;
			bool valid;
			
			// Check the current focused item.
			if (FocusedItem) {
				origTarget = FocusedItem.Target;
				if (CheckTarget(pp, origTarget, bestDFC))
					bestTarget = origTarget;
			}
			
			// Look for the item that's closest to the center of the player actor's field of view.
			// Also, look for any items that should always be picked up on touch.
			for (let i = BlockThingsIterator.Create(pp, usetopickup_fulluserange && pp is "PlayerPawn"? PlayerPawn(pp).UseRange : max(pp.Height, pp.Radius)); i.Next();)
			if (i.thing != bestTarget && i.thing is "Inventory") {
				let ci = UseToPickup.ActorClassInfo(i.thing.GetClass());
				
				if (ci && ci.AlwaysTouchPickup) {
					if (i.thing.bSpecial && IsTouching(pp, i.thing))
						i.thing.Touch(pp);
				}
				else if (CheckTarget(pp, i.thing, bestDFC)) {
					bestTarget = Inventory(i.thing);
					bestTargetCI = ci;
				}
			}
			
			if (FocusedItem && (!bestTarget || bestTarget != origTarget)) {
				// We're now focusing on something other than what's currently focused (either nothing or a different actor), so clear the current focus.
				ClearFocus();
			}
			
			if (bestTarget && bestTarget != origTarget)
				// Got a new target to focus on.
				FocusedItem = new("U2P_ItemHighlight").Init(self, bestTarget, bestTargetCI);
		}
		
		// Check if the player is allowed to pick up the focused item.
		if (
			enabled &&
			pp &&
			FocusedItem &&
			FocusedItem.Target &&
			FocusedItem.Tween == 1.
		) {
			// If so, then block the usual effects of the use button.
			Player.usedown = true;
			
			// Check if the player wants to pick up the item.
			if (
				(Player.cmd.buttons & BT_USE) &&
				!(Player.oldbuttons & BT_USE)
			)
				FocusedItem.Target.Touch(pp);
		}
	}
	
	/**
	 * Checks whether a target is valid, and if so, updates bestDFC.
	 *
	 * The target is valid if:
	 * • It is within the given range of the viewer.
	 * • Its distance from the center of the viewer's field of view (that is, how far the viewer would need to look left/right/up/down to look straight at the target) is less than bestDFC.
	 *
	 * @param viewer The viewing actor.
	 * @param target The actor that may or may not be a valid target.
	 * @param bestDFC Distance-from-center of currently focused target. This is an out parameter; if the given target is valid, bestDFC will be updated with the DFC of the given target.
	 * @return true if the target is valid; false otherwise.
	 */
	static bool CheckTarget(Actor viewer, Actor target, in out double bestDFC) {
		if (
			// Does it exist at all?
			!target ||
			// Can it be picked up?
			!target.bSpecial
		)
			// Nope.
			return false;
		
		// Compute relevant points, distances, and angles.
		let viewPos = viewer.Pos;
		if (viewer.player)
			viewPos.Z = viewer.player.viewz;
		else
			viewPos.Z += viewer.Height / 2.;
		
		U2P_ActorAdjustedGeometry targetGeom;
		targetGeom.Update(target, UseToPickup.ActorClassInfo(target.GetClass()));
		
		let vecTo = level.Vec3Diff(viewPos, targetGeom.CenterPos);
		let distTo = vecTo.Length();
		
		// Is it close enough?
		if (usetopickup_fulluserange && viewer is "PlayerPawn") {
			// Test by the viewer's use range.
			if (distTo > PlayerPawn(viewer).UseRange)
				return false;
		}
		else if (!IsTouching(viewer, target)) {
			// Test whether the actors are intersecting, ignoring viewpoints and angles.
			return false;
		}
		
		let dirTo = vecTo.Unit();
		let anglesTo = (
			atan2(dirTo.Y, dirTo.X),
			-asin(dirTo.Z)
		);
		Vector2 viewDA = (
			Actor.deltaangle(anglesTo.X, viewer.Angle),
			Actor.deltaangle(anglesTo.Y, viewer.Pitch)
		);
		let dfc = viewDA.Length();
		
		// Is it within acceptable angles?
		if (dfc >= bestDFC)
			return false;
		
		// Is there anything in the way?
		let trace = new("U2P_ItemReachabilityTracer");
		trace.IgnoreActors.Resize(2);
		trace.IgnoreActors[0] = viewer;
		trace.IgnoreActors[1] = target;
		if (trace.Trace(viewPos, viewer.CurSector, dirTo, distTo, 0))
			return false;
		
		// All checks pass!
		bestDFC = dfc;
		return true;
	}
	
	static clearscope bool IsTouching(Actor a, Actor b) {
		return
			a.Distance2D(b) <= max(a.Radius, b.Radius) &&
			a.Pos.Z <= b.Pos.Z + b.Height &&
			b.Pos.Z <= a.Pos.Z + a.Height;
	}
}

struct U2P_ActorAdjustedGeometry {
	Vector3 Pos, CenterPos;
	double Height, Radius;
	
	void Copy(U2P_ActorAdjustedGeometry other) {
		Pos = other.Pos;
		CenterPos = other.CenterPos;
		Height = other.Height;
		Radius = other.Radius;
	}
	
	play void Update(Actor a, U2P_ActorClassInfo classInfo, bool bobOffset = false) {
		Pos = a.Pos;
		Height = a.Height;
		Radius = a.Radius;
		
		if (!classInfo || (classInfo.UseSpriteDimensions && !(classInfo.OverrideRadius || classInfo.OverrideHeight))) {
			TextureID tex;
			bool flipped;
			Vector2 scale;
			// TODO: Account for sprite rotation?
			[tex, flipped, scale] = a.CurState.GetSpriteTexture(0, scale: a.Scale);
			
			if (tex.IsValid()) {
				let texSize = TexMan.GetScaledSize(tex);
				
				let h = texSize.Y * scale.Y;
				let r = texSize.X * scale.X;
				
				if (h >= 2. && r >= 2.) {
					Height = h;
					Radius = r;
					
					if (!classInfo || !classInfo.OverrideZOffset) {
						let texOffs = TexMan.GetScaledOffset(tex);
						Pos.Z += (texOffs.Y - texSize.Y) * scale.Y;
					}
				}
			}
		}
		
		if (classInfo) {
			if (classInfo.OverrideRadius)
				Radius = classInfo.Radius;
			if (classInfo.OverrideHeight)
				Height = classInfo.Height;
			if (classInfo.OverrideZOffset)
				Pos.Z += classInfo.ZOffset;
		}
		
		if (bobOffset)
			Pos.Z += a.GetBobOffset();
		
		CenterPos = Pos;
		CenterPos.Z += Height / 2;
	}
}

class U2P_ItemHighlight : Thinker {
	enum EHighlightState {
		FADING_IN,
		STEADY,
		FADING_OUT
	};
	
	U2P_PlayerState ps;
	Inventory Target;
	float Tween;
	protected EHighlightState HighlightState;
	protected float TweenChange;
	transient U2P_ActorClassInfo ClassInfo;
	private transient bool CheckedForClassInfo;
	private transient ui String PickUpText;
	
	// Record this information so that the highlight can fade out, even if the item disappears.
	U2P_ActorAdjustedGeometry TargetGeom;
	String TargetTag;
	
	U2P_ItemHighlight Init(U2P_PlayerState ps, Inventory target, U2P_ActorClassInfo classInfo = null) {
		// Tick after U2P_PlayerState does.
		ChangeStatNum(STAT_USER+1);
		
		self.ps = ps;
		self.Target = target;
		HighlightState = FADING_IN;
		self.ClassInfo = classInfo;
		return self;
	}
	
	override void Tick() {
		if (!ps || !ps.Player) {
			Destroy();
			return;
		}
		
		switch (ps.Player.playerstate) {
			case PST_DEAD:
			case PST_REBORN:
				// If player is dead, fade out.
				FadeOut();
				break;
			
			case PST_ENTER:
			case PST_GONE:
				// If player isn't present at all, then this object is no longer valid, so bail.
				Destroy();
				return;
			
			// Otherwise, carry on.
		}
		
		if (Target && Target.bSpecial) {
			if (!CheckedForClassInfo && !ClassInfo) {
				ClassInfo = UseToPickup.ActorClassInfo(Target.GetClass());
				CheckedForClassInfo = true;
			}
			
			TargetGeom.Update(Target, ClassInfo, bobOffset: true);
			
			if (ClassInfo && ClassInfo.ForceTag) {
				if (!TargetTag)
					TargetTag = StringTable.Localize(ClassInfo.Tag);
			}
			else {
				String cn = Target.GetClassName();
				TargetTag = Target.GetTag(
					ClassInfo && ClassInfo.Tag?
					ClassInfo.Tag :
					ClassInfo && ClassInfo.UsePickupMessageAsTag?
					Target.PickupMsg :
					cn
				);
				TargetTag = StringTable.Localize(TargetTag);
			}
		}
		else {
			// Target lost. Fade out.
			FadeOut();
		}
		
		if (HighlightState == FADING_IN || HighlightState == FADING_OUT) {
			double time;
			if (HighlightState == FADING_IN)
				time = ps.Settings.FadeInTime.GetFloat();
			else
				time = ps.Settings.FadeOutTime.GetFloat();
			
			// Avoid division by zero.
			// Division by zero would actually yield correct results (positive infinity), but the engine crashes instead of passing such a value through, so we have to special-case it.
			if (time <= 0.)
				TweenChange = 1;
			else
				TweenChange = 1. / (time * TICRATE);
			
			if (HighlightState == FADING_OUT)
				TweenChange = -TweenChange;
		}
		
		if (TweenChange)
			Tween = clamp(Tween + TweenChange, 0., 1.);
		
		if (Tween == 0.) {
			// Fully faded out.
			Destroy();
		}
		else if (Tween == 1.) {
			// Fully visible.
			HighlightState = STEADY;
			TweenChange = 0;
		}
	}
	
	void FadeOut() {
		HighlightState = FADING_OUT;
		Target = null;
	}
	
	const BackgroundColor_KeyBind = Color(0xffffffe6);
	const BracketTexName = "UseToPickup/bracket.png";
	private transient ui TextureID BracketTex;
	
	// Scale the brackets such that they're drawn 1:1 on a screen whose min(width,height) is this many pixels.
	const ScaleBase = 4000.;
	
	ui void Draw(U2P_DrawContext dc) {
		if (
			// Don't actually draw anything for anyone other than the console player.
			// Note that these highlighters have playsim effects too, so they still exist for other players; they just aren't drawn.
			ps.PlayerNum != consoleplayer ||
			// Don't bother drawing anything if opacity is zero!
			Tween <= 0. ||
			// If U2P_PlayerSettings hasn't been reinitialized yet, wait for that to happen.
			!ps.Settings
		)
			return;
		
		switch (ps.Player.playerstate) {
			case PST_ENTER:
			case PST_GONE:
				// Similarly, if the owning player isn't in the game, don't draw anything.
				return;
		}
		
		// Look up the bracket texture, if needed.
		if (!BracketTex.IsValid()) {
			BracketTex = TexMan.CheckForTexture(BracketTexName, TexMan.Type_Any);
			if (!BracketTex.IsValid())
				ThrowAbortException("%s can't find required texture %s!", GetClassName(), BracketTexName);
		}
		
		Color highlightColor = ps.Settings.HighlightColor.GetInt() | 0xff000000;
		let fracTween = Tween + TweenChange * dc.FracTic;
		let opacity = clamp(ps.Settings.HighlightOpacity.GetFloat(), 0., 1.) * fracTween;
		
		// Top left, bottom right
		Vector2 screenCoord[2];
		let halfRad = TargetGeom.Radius / 2;
		
		// Adapted from Pixel Eater's Fill Spectre.
		for (let corner = 0; corner < 4; corner++) {
			// Compute one corner at a time.
			// The corner numbers are: 0 = top left, 1 = top right, 2 = bottom left, 3 = bottom right
			let vert = dc.ViewPos + LevelLocals.Vec3Diff(
				dc.ViewPos,
				TargetGeom.Pos + (
					// `corner & 1` is only true for the top right and bottom right corners.
					sin(dc.Viewer.Angle) * halfRad * (corner & 1? 1. : -1.),
					cos(dc.Viewer.Angle) * halfRad * (corner & 1? -1. : 1.),
					// `corner & 2` is only true for the bottom left and bottom right corners.
					corner & 2? 0 : TargetGeom.Height
				)
			);
			
			let ndc = dc.WorldToClip.multiplyVector3(vert).asVector3();
			
			if (ndc.Z > 1. || ndc.Z < -1.)
				// Out of camera view. Don't draw anything.
				// This is the reason why we store all four coordinates in the screenCoord and then loop over them again: if *any* of the coordinates are out of view, we need to not draw anything!
				return;
			
			let cornerCoord = U2P_GlobalMaths.ndcToViewPort(ndc);
			
			// That projects the corners of the sprite on the screen. Now, make a rectangle from the coordinates.
			if (!corner) {
				// For the first corner, just use that coordinate to start.
				screenCoord[0] = screenCoord[1] = cornerCoord;
			}
			else {
				// From there, stretch out the rectangle to fit the thing.
				screenCoord[0].X = min(screenCoord[0].X, cornerCoord.X);
				screenCoord[0].Y = min(screenCoord[0].Y, cornerCoord.Y);
				screenCoord[1].X = max(screenCoord[1].X, cornerCoord.X);
				screenCoord[1].Y = max(screenCoord[1].Y, cornerCoord.Y);
			}
		}
		
		let texSize = TexMan.GetScaledSize(BracketTex) * (min(Screen.GetWidth(), Screen.GetHeight()) / ScaleBase);
		
		// Make sure the brackets don't overlap.
		{
			let centerCoord = screenCoord[0] + ((screenCoord[1] - screenCoord[0]) * .5);
			screenCoord[0].X = min(screenCoord[0].X, centerCoord.X - texSize.X);
			screenCoord[0].Y = min(screenCoord[0].Y, centerCoord.Y - texSize.Y);
			screenCoord[1].X = max(screenCoord[1].X, centerCoord.X + texSize.X);
			screenCoord[1].Y = max(screenCoord[1].Y, centerCoord.Y + texSize.Y);
		}
		
		for (let corner = 0; corner < 4; corner++) {
			Screen.DrawTexture(
				BracketTex, false,
				screenCoord[corner & 1].X - (corner & 1? texSize.X : 0.),
				// (2 & 2) = 2, but we need 0 or 1. !! gives us that.
				screenCoord[!!(corner & 2)].Y - (corner & 2? texSize.Y : 0),
				DTA_Alpha, opacity,
				DTA_AlphaChannel, true,
				DTA_FillColor, highlightColor,
				DTA_FlipX, corner & 1,
				DTA_FlipY, !!(corner & 2),
				DTA_DestWidthF, texSize.X,
				DTA_DestHeightF, texSize.Y
			);
		}
		
		let fontHeight = dc.MsgFont.GetHeight() * CleanYFac;
		
		Vector2 textCoord = (
			screenCoord[0].X,
			screenCoord[1].Y + (fontHeight * .8)
		);
		
		Screen.DrawText(
			dc.MsgFont, Font.CR_WHITE,
			textCoord.X, textCoord.Y,
			TargetTag,
			DTA_TextLen, int(TargetTag.Length() * fracTween),
			DTA_Alpha, opacity,
			DTA_CleanNoMove, true,
			DTA_Color, highlightColor
		);
		
		textCoord.Y += fontHeight * 1.8;
		
		{
			// Draw the label saying which button to push.
			String keyName;
			{
				int bindingKeys[2];
				[bindingKeys[0], bindingKeys[1]] = Bindings.GetKeysForCommand("+use");
				keyName = KeyBindings.NameKeys(bindingKeys[0], bindingKeys[1]);
			}
			let keyNameWidth = dc.MsgFont.StringWidth(keyName) * CleanXFac;
			let borderWidth = max(fontHeight >> 2, 1);
			
			Screen.Dim(
				BackgroundColor_KeyBind,
				opacity,
				textCoord.X - borderWidth,
				textCoord.Y - borderWidth,
				keyNameWidth + borderWidth + borderWidth,
				fontHeight + borderWidth + borderWidth
			);
			
			Screen.DrawText(
				dc.MsgFont, Font.CR_WHITE,
				textCoord.X, textCoord.Y,
				keyName,
				DTA_Alpha, opacity,
				DTA_CleanNoMove, true,
				DTA_Color, highlightColor
			);
			
			// Advance the draw position for the text.
			textCoord.X += keyNameWidth + borderWidth + borderWidth + dc.MsgFont.GetCharWidth(20) * 2;
		}
		
		// Draw the “pick up” label.
		if (!PickUpText)
			PickUpText = StringTable.Localize("U2P_PickUpText", prefixed: false);
		
		Screen.DrawText(
			dc.MsgFont, Font.CR_WHITE,
			textCoord.X, textCoord.Y,
			PickUpText,
			DTA_TextLen, int(PickUpText.Length() * fracTween),
			DTA_Alpha, opacity,
			DTA_CleanNoMove, true,
			DTA_Color, highlightColor
		);
	}
}

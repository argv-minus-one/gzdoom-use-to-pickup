Version "3.4"

#include "UseToPickup/INIFile.zc"
// See https://gitlab.com/Gutawer/gzdoom-gutamatics/
#include "U2P_Gutamatics/Include.zsc"

class UseToPickup : StaticEventHandler {
	Font MsgFont;
	private ThinkerIterator PlayerStates, Drawables;
	private Array<U2P_ActorClassInfo> ClassInfo;
	
	override void OnRegister() {
		MsgFont = Font.FindFont('SMALLFONT');
		Drawables = ThinkerIterator.Create('U2P_ItemHighlight');
		PlayerStates = ThinkerIterator.Create('U2P_PlayerState');
		
		ClassInfo.Clear();
		
		U2P_INIFile ini;
		ini.ReadLumpsNamed("UseToPickup.ini");
		ini.MergeByActorClass();
		
		for (let aci = 0, acs = AllActorClasses.Size(); aci < acs; aci++) {
			let ac = AllActorClasses[aci];
			let sec = ini.Section(ac.GetClassName());
			if (!sec)
				continue;
			
			let ci = new("U2P_ActorClassInfo");
			ci.ActorClass = ac;
			ci.Init(sec);
			ClassInfo.Push(ci);
		}
	}
	
	override void WorldLoaded(WorldEvent evt) {
		// If there are any stale or duplicate U2P_PlayerState objects, clean them up now.
		// Warn about duplicates; that's a bug.
		U2P_PlayerState psa[MAXPLAYERS];
		for (let i = 0; i < MAXPLAYERS; i++)
			psa[i] = null;
		
		U2P_PlayerState ps;
		for (PlayerStates.Reinit(); ps = U2P_PlayerState(PlayerStates.Next());) {
			let p = ps.PlayerNum;
			
			if (!playeringame[p]) {
				// This player is no longer in-game. Disconnected during loading, perhaps?
				ps.Destroy();
			}
			else if (psa[p]) {
				Console.Printf("\cgMultiple U2P_PlayerState instances for player number %d! Deleting one of them.", p);
				ps.Destroy();
			}
			else
				psa[p] = ps;
		}
	}
	
	U2P_PlayerState PlayerStateOf(int p) {
		U2P_PlayerState ps;
		for (PlayerStates.Reinit(); ps = U2P_PlayerState(PlayerStates.Next());)
		if (ps.PlayerNum == p)
			return ps;
		
		return null;
	}
	
	override void PlayerEntered(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		
		// Don't apply to bots.
		if (players[p].bot)
			return;
		
		// Find a U2P_PlayerState for this player.
		if (!PlayerStateOf(p))
			// If none exists, create one.
			new('U2P_PlayerState').Init(players[p], p);
	}
	
	override void PlayerRespawned(PlayerEvent evt) {
		// Clear the focus of the respawning player actor.
		// This will happen anyway if the player spends at least one tic dead, but just in case…
		let ps = PlayerStateOf(evt.PlayerNumber);
		if (ps)
			ps.ClearFocus();
	}
	
	override void PlayerDisconnected(PlayerEvent evt) {
		// Find and destroy the U2P_PlayerState for the disconnecting player.
		let ps = PlayerStateOf(evt.PlayerNumber);
		if (ps)
			ps.Destroy();
	}
	
	override void RenderOverlay(RenderEvent evt) {
		if (automapactive || !playeringame[consoleplayer])
			return;
		
		U2P_DrawContext dc;
		dc.MsgFont = MsgFont;
		dc.InitFromRenderEvent(evt);
		
		Drawables.Reinit();
		for (let drawable = Drawables.Next(); drawable; drawable = Drawables.Next())
			U2P_ItemHighlight(drawable).Draw(dc);
	}
	
	static clearscope U2P_ActorClassInfo ActorClassInfo(Class<Actor> actorClass) {
		let o = UseToPickup(StaticEventHandler.Find('UseToPickup'));
		
		for (let idx = 0, size = o.ClassInfo.Size(); idx < size; idx++) {
			let ci = o.ClassInfo[idx];
			if (ci.ActorClass == actorClass)
				return ci;
		}
		
		return null;
	}
	
	override void NetworkProcess(ConsoleEvent evt) {
		if (evt.Name == "UseToPickup_Push") {
			let ps = PlayerStateOf(evt.Player);
			if (ps)
				ps.PushFocusedItem();
			else
				Console.Printf("\cgNo U2P_PlayerState for player %d!", evt.Player);
		}
	}
	
	static const Name CVarNames[] = {
		'usetopickup_enabled',
		'usetopickup_highlight_color',
		'usetopickup_highlight_opacity',
		'usetopickup_fadeintime',
		'usetopickup_fadeouttime',
		'usetopickup_fulluserange',
		'usetopickup_pickupdelay',
		'usetopickup_scanfreq'
	};
	
	override void ConsoleProcess(ConsoleEvent evt) {
		if (evt.Name == 'UseToPickup_ResetAllCVars') {
			for (let i = 0, s = CVarNames.Size(); i < s; i++)
				CVar.FindCVar(CVarNames[i]).ResetToDefault();
		}
		else if (evt.Name == 'UseToPickup_DumpPlayerStates') {
			U2P_PlayerState ps;
			for (PlayerStates.Reinit(); ps = U2P_PlayerState(PlayerStates.Next());)
				Console.Printf(
					"Player %d (%s): phase %d, focused item %s",
					ps.PlayerNum,
					ps.Player.mo? ps.Player.mo.GetClassName() : 'None',
					ps.SelectPhase,
					ps.FocusedItem && ps.FocusedItem.Target?
						ps.FocusedItem.Target.GetClassName()
						: 'None'
				);
		}
	}
}

class U2P_ActorClassInfo {
	Class<Actor> ActorClass;
	String Tag;
	bool AlwaysTouchPickup, ForceTag, UsePickupMessageAsTag, UseSpriteDimensions, OverrideRadius, OverrideHeight, OverrideZOffset;
	double Radius, Height, ZOffset;
	
	void Init(U2P_INISection section) {
		Tag = section.Get("Tag");
		AlwaysTouchPickup = section.GetBool("AlwaysTouchPickup");
		ForceTag = section.GetBool("ForceTag");
		UsePickupMessageAsTag = section.GetBool("UsePickupMessageAsTag");
		UseSpriteDimensions = section.GetBool("UseSpriteDimensions", default: true);
		Radius = section.GetDouble("Radius", default: double.NaN);
		Height = section.GetDouble("Height", default: double.NaN);
		ZOffset = section.GetDouble("ZOffset", default: double.NaN);
		
		// This is a fun little trick. Unlike all other floating-point values, NaN does *not* equal itself, so we can detect whether a value is NaN by comparing it to itself.
		OverrideRadius = Radius == Radius;
		OverrideHeight = Height == Height;
		OverrideZOffset = ZOffset == ZOffset;
	}
}

struct U2P_DrawContext ui {
	Actor Viewer;
	Vector3 ViewPos, ViewAngles;
	U2P_Matrix WorldToClip;
	double FracTic;
	float ViewerFOV;
	Font MsgFont;
	
	void InitFromRenderEvent(RenderEvent evt) {
		Viewer = evt.Camera;
		ViewPos = evt.ViewPos;
		ViewAngles = (evt.ViewAngle, evt.ViewPitch, evt.ViewRoll);
		FracTic = evt.FracTic;
		ViewerFOV = players[consoleplayer].FOV;
		Init();
	}
	
	// This needs to be called *after* ViewPos, ViewAngles, and ViewerFOV are set.
	void Init() {
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		WorldToClip = U2P_Matrix.worldToClip(ViewPos, ViewAngles.X, ViewAngles.Y, ViewAngles.Z, ViewerFOV);
	}
}

class U2P_ItemReachabilityTracer : LineTracer {
	Array<Actor> IgnoreActors;
	
	override ETraceStatus TraceCallback() {
		switch (Results.HitType) {
			case TRACE_HitFloor:
			case TRACE_HitCeiling:
				return TRACE_Stop;
			
			case TRACE_HitActor:
				if (Results.HitActor.bShootable && IgnoreActors.Find(Results.HitActor) == IgnoreActors.Size())
					return TRACE_Stop;
				else
					break;
			
			case TRACE_HitWall:
				if (
					!(Results.HitLine.flags & Line.ML_TWOSIDED) ||
					Results.HitLine.flags & (Line.ML_BLOCKEVERYTHING | Line.ML_BLOCKUSE) ||
					Results.Tier != TIER_Middle
				)
					return TRACE_Stop;
		}
		
		return TRACE_Skip;
	}
}

// There should always be exactly one instance of this class for every instance of U2P_PlayerState.
// It's a separate class because CVars, and therefore U2P_PlayerSettings, have a different lifecycle (they aren't saved, and are reinitialized on loading a save) than U2P_PlayerState (which is saved).
class U2P_PlayerSettings {
	CVar IsEnabled, HighlightColor, HighlightOpacity, FadeInTime, FadeOutTime, PickupDelay;
	
	U2P_PlayerSettings Init(PlayerInfo player) {
		IsEnabled = CVar.GetCVar('usetopickup_enabled', Player);
		HighlightColor = CVar.GetCVar('usetopickup_highlight_color', Player);
		HighlightOpacity = CVar.GetCVar('usetopickup_highlight_opacity', Player);
		FadeInTime = CVar.GetCVar('usetopickup_fadeintime', Player);
		FadeOutTime = CVar.GetCVar('usetopickup_fadeouttime', Player);
		PickupDelay = CVar.GetCVar('usetopickup_pickupdelay', Player);
		return self;
	}
}

class U2P_PlayerState : Thinker {
	const HighlightFOV = 25.;
	const PushCooldownTics = 15;
	
	U2P_ItemHighlight FocusedItem;
	PlayerInfo Player;
	int PlayerNum;
	uint8 SelectPhase;
	transient U2P_PlayerSettings Settings;
	transient private uint8 PushCooldown, PickupDelay;
	
	U2P_PlayerState Init(PlayerInfo player, int playerNum) {
		// Tick before U2P_ItemHighlight does.
		ChangeStatNum(STAT_USER);
		
		self.Player = player;
		self.PlayerNum = playerNum;
		
		// Target selection runs every 4 tics. In multiplayer with a lot of players, this could result in stuttering, from target selection happening for all of them at the same time (every fourth tic). So, we offset which of every fourth tic to perform target selection on, based on the player number. For example:
		// Player 0 will select targets on tic 0, 3, 6, …
		// Player 1 will select targets on tic 1, 4, 7, …
		// Player 2 will select targets on tic 2, 5, 8, …
		// Player 4 will select targets on tic 0, 3, 6, …
		// Player 5 will select targets on tic 1, 4, 7, …
		SelectPhase = playerNum & 3;
		
		return self;
	}
	
	void ClearFocus() {
		if (FocusedItem) {
			FocusedItem.FadeOut();
			FocusedItem = null;
		}
	}
	
	override void OnDestroy() {
		if (FocusedItem)
			FocusedItem.Destroy();
	}
	
	void PushFocusedItem() {
		if (PushCooldown || !FocusedItem)
			return;
		
		let item = FocusedItem.Target;
		if (!item || !item.bSpecial)
			return;
		
		let pp = Player.mo;
		if (!pp)
			return;
		
		item.Thrust(1, pp.AngleTo(item));
		PushCooldown = PushCooldownTics;
	}
	
	// Apologies for the humongous do-everything function, but this is all done in one place as an optimization. ZScript has a high performance penalty for function calls, and this function runs in a fairly tight loop (once per tic, or 35 times per second).
	override void Tick() {
		if (!Settings)
			Settings = new('U2P_PlayerSettings').Init(Player);
		
		if (Player.playerstate != PST_LIVE || Player.bot) {
			// For dead players (and bots, if a regular player somehow becomes a bot), just clear everything out.
			ClearFocus();
			PushCooldown = 0;
			if (Player.mo)
				Player.mo.bPickup = GetDefaultByType(Player.mo.GetClass()).bPickup;
			return;
		}
		
		// Clear the focused item, if appropriate.
		if (FocusedItem && !FocusedItem.Target)
			FocusedItem = null;
		
		if (PushCooldown)
			PushCooldown--;
		if (PickupDelay)
			PickupDelay--;
		
		let pp = Player.mo;
		let enabled = Settings.IsEnabled.GetBool();
		
		// Block normal pickup, if appropriate.
		if (pp)
			pp.bPickup = enabled? false : GetDefaultByType(pp.GetClass()).bPickup;
		
		// Clear the focused item, if appropriate.
		if (!enabled || (FocusedItem && (!FocusedItem.Target || !FocusedItem.Target.bSpecial)))
			ClearFocus();
		
		let scanFreq = max(1, usetopickup_scanfreq);
		if (pp && enabled && (gametic % scanFreq) == (PlayerNum % scanFreq)) {
			// Search for items nearby.
			Inventory bestTarget = null;
			U2P_ActorClassInfo bestTargetCI = null;
			double bestDFC = HighlightFOV;
			let viewPos = pp.Pos;
			
			if (pp.player)
				viewPos.Z = pp.player.viewz;
			else
				viewPos.Z += pp.Height / 2.;
			
			let viewPosOfs = viewPos - pp.Pos;
			
			BlockThingsIterator i;
			double range;
			bool range3D;
			
			if (usetopickup_fulluserange) {
				let pp_ = PlayerPawn(pp);
				// Search for items in a sphere around the viewpoint.
				range = max(
					pp_? pp_.UseRange : 0.,
					pp.Radius,
					pp.Height
				);
				range3D = true;
				i = BlockThingsIterator.CreateFromPos(viewPos.X, viewPos.Y, viewPos.Z, range, range, false);
			}
			else {
				// Search only for items directly touching the actor.
				range = 0;
				range3D = false;
				i = BlockThingsIterator.Create(pp);
			}
			
			// Look for the item that's closest to the center of the player actor's field of view.
			// Also, look for any items that should always be picked up on touch.
			while (i.Next()) {
				let item = Inventory(i.thing);
				if (!item || !item.bSpecial)
					continue;
				
				// Doom actors are not cylindrical but square shaped. One must check the XY axes separately to determine whether they're touching.
				// https://forum.zdoom.org/viewtopic.php?f=122&t=61508&p=1066932#p1066643
				bool touching =
					pp.Pos.X + pp.Radius >= item.Pos.X - item.Radius &&
					pp.Pos.X - pp.Radius <= item.Pos.X + item.Radius &&
					pp.Pos.Y + pp.Radius >= item.Pos.Y - item.Radius &&
					pp.Pos.Y - pp.Radius <= item.Pos.Y + item.Radius &&
					pp.Pos.Z             <= item.Pos.Z + item.Height &&
					pp.Pos.Z + pp.Height >= item.Pos.Z;
				
				let ci = UseToPickup.ActorClassInfo(item.GetClass());
				
				if (ci && ci.AlwaysTouchPickup) {
					// For items that can only be picked up by touch, just check if they're touching.
					if (touching)
						item.Touch(pp);
					// Ignore them otherwise.
				}
				else {
					// For everything else, check how close it is to the center of the player's view.
					U2P_ActorAdjustedGeometry itemGeom;
					itemGeom.Update(item, ci);
					
					let vecTo = level.Vec3Diff(viewPos, itemGeom.CenterPos);
					let distTo = vecTo.Length();
					
					// Is the item closer to the center of the player's view?
					let dirTo = vecTo.Unit();
					let anglesTo = (
						atan2(dirTo.Y, dirTo.X),
						-asin(dirTo.Z)
					);
					let viewDA = (
						Actor.deltaangle(anglesTo.X, pp.Angle),
						Actor.deltaangle(anglesTo.Y, pp.Pitch)
					);
					let dfc = viewDA.Length();
					
					if (dfc >= bestDFC)
						continue;
					
					if (!touching) {
						// If fulluserange is enabled, items can be picked up without touching them.
						if (range3D) {
							// Is it close enough?
							if (distTo > range)
								continue;
							
							// Is anything in the way?
							let trace = new('U2P_ItemReachabilityTracer');
							trace.IgnoreActors.Resize(2);
							trace.IgnoreActors[0] = pp;
							trace.IgnoreActors[1] = item;
							if (trace.Trace(viewPos, pp.CurSector, dirTo, distTo, 0))
								continue;
						}
						// Otherwise, one must touch the item in order to pick it up.
						else
							continue;
					}
					
					// All checks pass!
					bestTarget = item;
					bestTargetCI = ci;
					bestDFC = dfc;
				}
			}
			
			if (FocusedItem && (!bestTarget || bestTarget != FocusedItem.Target)) {
				// We're now focusing on something other than what's currently focused (either nothing or a different actor), so clear the current focus.
				ClearFocus();
			}
			
			if (bestTarget && !FocusedItem) {
				// Got a new target to focus on. (FocusedItem will be non-null iff the target hasn't changed.)
				FocusedItem = new('U2P_ItemHighlight').Init(self, bestTarget, bestTargetCI);
				PickupDelay = clamp(uint(Settings.PickupDelay.GetFloat() * TICRATE + .5), 0, 255);
			}
		}
		
		// Check if the player is allowed to pick up the focused item.
		if (
			enabled &&
			pp &&
			!PickupDelay &&
			FocusedItem &&
			FocusedItem.Target
		) {
			// If so, then block the usual effects of the use button.
			Player.usedown = true;
			
			// Check if the player wants to pick up the item.
			if (
				(Player.cmd.buttons & BT_USE) &&
				!(Player.oldbuttons & BT_USE)
			)
				FocusedItem.Target.Touch(pp);
		}
	}
}

struct U2P_ActorAdjustedGeometry {
	Vector3 Pos, CenterPos;
	double Height, Radius;
	
	void Copy(U2P_ActorAdjustedGeometry other) {
		Pos = other.Pos;
		CenterPos = other.CenterPos;
		Height = other.Height;
		Radius = other.Radius;
	}
	
	play void Update(Actor a, U2P_ActorClassInfo classInfo, bool bobOffset = false) {
		Pos = a.Pos;
		Height = a.Height;
		Radius = a.Radius;
		
		if (!classInfo || (classInfo.UseSpriteDimensions && !(classInfo.OverrideRadius || classInfo.OverrideHeight))) {
			TextureID tex;
			bool flipped;
			Vector2 scale;
			// TODO: Account for sprite rotation?
			[tex, flipped, scale] = a.CurState.GetSpriteTexture(0, scale: a.Scale);
			
			if (tex.IsValid()) {
				let texSize = TexMan.GetScaledSize(tex);
				
				let h = texSize.Y * scale.Y;
				let r = texSize.X * scale.X;
				
				if (h >= 2. && r >= 2.) {
					Height = h;
					Radius = r;
					
					if (!classInfo || !classInfo.OverrideZOffset) {
						let texOffs = TexMan.GetScaledOffset(tex);
						Pos.Z += (texOffs.Y - texSize.Y) * scale.Y;
					}
				}
			}
		}
		
		if (classInfo) {
			if (classInfo.OverrideRadius)
				Radius = classInfo.Radius;
			if (classInfo.OverrideHeight)
				Height = classInfo.Height;
			if (classInfo.OverrideZOffset)
				Pos.Z += classInfo.ZOffset;
		}
		
		if (bobOffset)
			Pos.Z += a.GetBobOffset();
		
		CenterPos = Pos;
		CenterPos.Z += Height / 2;
	}
}

class U2P_ItemHighlight : Thinker {
	enum EHighlightState {
		FADING_IN,
		STEADY,
		FADING_OUT
	};
	
	U2P_PlayerState ps;
	Inventory Target;
	float Tween;
	protected EHighlightState HighlightState;
	protected float TweenChange;
	transient U2P_ActorClassInfo ClassInfo;
	private transient bool CheckedForClassInfo;
	private transient ui String PickUpText;
	
	// Record this information so that the highlight can fade out, even if the item disappears.
	U2P_ActorAdjustedGeometry TargetGeom;
	String TargetTag;
	
	U2P_ItemHighlight Init(U2P_PlayerState ps, Inventory target, U2P_ActorClassInfo classInfo = null) {
		// Tick after U2P_PlayerState does.
		ChangeStatNum(STAT_USER+1);
		
		self.ps = ps;
		self.Target = target;
		HighlightState = FADING_IN;
		self.ClassInfo = classInfo;
		return self;
	}
	
	override void Tick() {
		if (!ps || !ps.Player) {
			Destroy();
			return;
		}
		
		switch (ps.Player.playerstate) {
			case PST_DEAD:
			case PST_REBORN:
				// If player is dead, fade out.
				FadeOut();
				break;
			
			case PST_ENTER:
			case PST_GONE:
				// If player isn't present at all, then this object is no longer valid, so bail.
				Destroy();
				return;
			
			// Otherwise, carry on.
		}
		
		if (Target && Target.bSpecial) {
			if (!CheckedForClassInfo && !ClassInfo) {
				ClassInfo = UseToPickup.ActorClassInfo(Target.GetClass());
				CheckedForClassInfo = true;
			}
			
			TargetGeom.Update(Target, ClassInfo, bobOffset: true);
			
			if (ClassInfo && ClassInfo.ForceTag) {
				if (!TargetTag)
					TargetTag = StringTable.Localize(ClassInfo.Tag);
			}
			else {
				String cn = Target.GetClassName();
				TargetTag = Target.GetTag(
					ClassInfo && ClassInfo.Tag?
					ClassInfo.Tag :
					ClassInfo && ClassInfo.UsePickupMessageAsTag?
					Target.PickupMsg :
					cn
				);
				TargetTag = StringTable.Localize(TargetTag);
			}
		}
		else {
			// Target lost. Fade out.
			FadeOut();
		}
		
		if (HighlightState == FADING_IN || HighlightState == FADING_OUT) {
			double time;
			if (HighlightState == FADING_IN)
				time = ps.Settings.FadeInTime.GetFloat();
			else
				time = ps.Settings.FadeOutTime.GetFloat();
			
			// Avoid division by zero.
			// Division by zero would actually yield correct results (positive infinity), but the engine crashes instead of passing such a value through, so we have to special-case it.
			// Inspired by AFADoomer: https://forum.zdoom.org/posting.php?mode=reply&f=18&t=61454#pr1065822
			TweenChange = 1. / (max(time, double.epsilon) * TICRATE);
			
			if (HighlightState == FADING_OUT)
				TweenChange = -TweenChange;
		}
		
		if (TweenChange)
			Tween = clamp(Tween + TweenChange, 0., 1.);
		
		if (Tween == 0.) {
			// Fully faded out.
			Destroy();
		}
		else if (Tween == 1.) {
			// Fully visible.
			HighlightState = STEADY;
			TweenChange = 0;
		}
	}
	
	void FadeOut() {
		HighlightState = FADING_OUT;
		Target = null;
	}
	
	const BackgroundColor_KeyBind = Color(0xffffffe6);
	const BracketTexName = "UseToPickup/bracket.png";
	private transient ui TextureID BracketTex;
	
	// Scale the brackets such that they're drawn 1:1 on a screen whose min(width,height) is this many pixels.
	const ScaleBase = 4000.;
	
	ui void Draw(U2P_DrawContext dc) {
		if (
			// Don't actually draw anything for anyone other than the console player.
			// Note that these highlighters have playsim effects too, so they still exist for other players; they just aren't drawn.
			ps.PlayerNum != consoleplayer ||
			// Don't bother drawing anything if opacity is zero!
			Tween <= 0. ||
			// If U2P_PlayerSettings hasn't been reinitialized yet, wait for that to happen.
			!ps.Settings
		)
			return;
		
		switch (ps.Player.playerstate) {
			case PST_ENTER:
			case PST_GONE:
				// Similarly, if the owning player isn't in the game, don't draw anything.
				return;
		}
		
		// Look up the bracket texture, if needed.
		if (!BracketTex.IsValid()) {
			BracketTex = TexMan.CheckForTexture(BracketTexName, TexMan.Type_Any);
			if (!BracketTex.IsValid())
				ThrowAbortException("%s can't find required texture %s!", GetClassName(), BracketTexName);
		}
		
		Color highlightColor = ps.Settings.HighlightColor.GetInt() | 0xff000000;
		let fracTween = Tween + TweenChange * dc.FracTic;
		let opacity = clamp(ps.Settings.HighlightOpacity.GetFloat(), 0., 1.) * fracTween;
		
		// Top left, bottom right
		Vector2 screenCoord[2];
		let halfRad = TargetGeom.Radius / 2;
		
		// Adapted from Pixel Eater's Fill Spectre.
		for (let corner = 0; corner < 4; corner++) {
			// Compute one corner at a time.
			// The corner numbers are: 0 = top left, 1 = top right, 2 = bottom left, 3 = bottom right
			let vert = dc.ViewPos + LevelLocals.Vec3Diff(
				dc.ViewPos,
				TargetGeom.Pos + (
					// `corner & 1` is only true for the top right and bottom right corners.
					sin(dc.Viewer.Angle) * halfRad * (corner & 1? 1. : -1.),
					cos(dc.Viewer.Angle) * halfRad * (corner & 1? -1. : 1.),
					// `corner & 2` is only true for the bottom left and bottom right corners.
					corner & 2? 0 : TargetGeom.Height
				)
			);
			
			let ndc = dc.WorldToClip.multiplyVector3(vert).asVector3();
			
			if (ndc.Z > 1. || ndc.Z < -1.)
				// Out of camera view. Don't draw anything.
				// This is the reason why we store all four coordinates in the screenCoord and then loop over them again: if *any* of the coordinates are out of view, we need to not draw anything!
				return;
			
			let cornerCoord = U2P_GlobalMaths.ndcToViewPort(ndc);
			
			// That projects the corners of the sprite on the screen. Now, make a rectangle from the coordinates.
			if (!corner) {
				// For the first corner, just use that coordinate to start.
				screenCoord[0] = screenCoord[1] = cornerCoord;
			}
			else {
				// From there, stretch out the rectangle to fit the thing.
				screenCoord[0].X = min(screenCoord[0].X, cornerCoord.X);
				screenCoord[0].Y = min(screenCoord[0].Y, cornerCoord.Y);
				screenCoord[1].X = max(screenCoord[1].X, cornerCoord.X);
				screenCoord[1].Y = max(screenCoord[1].Y, cornerCoord.Y);
			}
		}
		
		let texSize = TexMan.GetScaledSize(BracketTex) * (min(Screen.GetWidth(), Screen.GetHeight()) / ScaleBase);
		
		// Make sure the brackets don't overlap.
		{
			let centerCoord = screenCoord[0] + ((screenCoord[1] - screenCoord[0]) * .5);
			screenCoord[0].X = min(screenCoord[0].X, centerCoord.X - texSize.X);
			screenCoord[0].Y = min(screenCoord[0].Y, centerCoord.Y - texSize.Y);
			screenCoord[1].X = max(screenCoord[1].X, centerCoord.X + texSize.X);
			screenCoord[1].Y = max(screenCoord[1].Y, centerCoord.Y + texSize.Y);
		}
		
		for (let corner = 0; corner < 4; corner++) {
			Screen.DrawTexture(
				BracketTex, false,
				screenCoord[corner & 1].X - (corner & 1? texSize.X : 0.),
				// (2 & 2) = 2, but we need 0 or 1. !! gives us that.
				screenCoord[!!(corner & 2)].Y - (corner & 2? texSize.Y : 0),
				DTA_Alpha, opacity,
				DTA_AlphaChannel, true,
				DTA_FillColor, highlightColor,
				DTA_FlipX, corner & 1,
				DTA_FlipY, !!(corner & 2),
				DTA_DestWidthF, texSize.X,
				DTA_DestHeightF, texSize.Y
			);
		}
		
		let fontHeight = dc.MsgFont.GetHeight() * CleanYFac;
		
		Vector2 textCoord = (
			screenCoord[0].X,
			screenCoord[1].Y + (fontHeight * .8)
		);
		
		Screen.DrawText(
			dc.MsgFont, Font.CR_WHITE,
			textCoord.X, textCoord.Y,
			TargetTag,
			DTA_TextLen, int(TargetTag.Length() * fracTween),
			DTA_Alpha, opacity,
			DTA_CleanNoMove, true,
			DTA_Color, highlightColor
		);
		
		textCoord.Y += fontHeight * 1.8;
		
		{
			// Draw the label saying which button to push.
			String keyName;
			{
				int bindingKeys[2];
				[bindingKeys[0], bindingKeys[1]] = Bindings.GetKeysForCommand("+use");
				keyName = KeyBindings.NameKeys(bindingKeys[0], bindingKeys[1]);
			}
			let keyNameWidth = dc.MsgFont.StringWidth(keyName) * CleanXFac;
			let borderWidth = max(fontHeight >> 2, 1);
			
			Screen.Dim(
				BackgroundColor_KeyBind,
				opacity,
				textCoord.X - borderWidth,
				textCoord.Y - borderWidth,
				keyNameWidth + borderWidth + borderWidth,
				fontHeight + borderWidth + borderWidth
			);
			
			Screen.DrawText(
				dc.MsgFont, Font.CR_WHITE,
				textCoord.X, textCoord.Y,
				keyName,
				DTA_Alpha, opacity,
				DTA_CleanNoMove, true,
				DTA_Color, highlightColor
			);
			
			// Advance the draw position for the text.
			textCoord.X += keyNameWidth + borderWidth + borderWidth + dc.MsgFont.GetCharWidth(20) * 2;
		}
		
		// Draw the “pick up” label.
		if (!PickUpText)
			PickUpText = StringTable.Localize("U2P_PickUpText", prefixed: false);
		
		Screen.DrawText(
			dc.MsgFont, Font.CR_WHITE,
			textCoord.X, textCoord.Y,
			PickUpText,
			DTA_TextLen, int(PickUpText.Length() * fracTween),
			DTA_Alpha, opacity,
			DTA_CleanNoMove, true,
			DTA_Color, highlightColor
		);
	}
}

Version "3.4"

// See https://gitlab.com/Gutawer/gzdoom-gutamatics/
#include "U2P_Gutamatics/Include.zsc"

class UseToPickup : StaticEventHandler {
	U2P_PlayerState PlayerStates[MAXPLAYERS];
	Font MsgFont;
	
	override void OnRegister() {
		MsgFont = Font.FindFont('SMALLFONT');
	}
	
	override void WorldTick() {
		for (let p = 0; p < MAXPLAYERS; p++)
		if (playeringame[p]) {
			PlayerStates[p].Tick();
			
			let pp = players[p].mo;
			if (!pp || pp.Health <= 0) {
				PlayerStates[p].FadeOutAll();
				continue;
			}
		}
	}
	
	override void PlayerEntered(PlayerEvent evt) {
		let p = evt.PlayerNumber;
		PlayerStates[p].Init(players[p]);
	}
	
	override void PlayerRespawned(PlayerEvent evt) {
		PlayerStates[evt.PlayerNumber].Clear();
	}
	
	override void PlayerDisconnected(PlayerEvent evt) {
		PlayerStates[evt.PlayerNumber].Clear(hard: true);
	}
	
	override void RenderOverlay(RenderEvent evt) {
		if (automapactive || !playeringame[consoleplayer])
			return;
		
		U2P_DrawContext dc;
		dc.MsgFont = MsgFont;
		dc.InitFromRenderEvent(evt);
		PlayerStates[consoleplayer].Draw(dc);
	}
}

struct U2P_DrawContext ui {
	Actor Viewer;
	Vector3 ViewPos, ViewAngles;
	U2P_Matrix WorldToClip;
	double FracTic;
	float ViewerFOV;
	Font MsgFont;
	
	void InitFromRenderEvent(RenderEvent evt) {
		Viewer = evt.Camera;
		ViewPos = evt.ViewPos;
		ViewAngles = (evt.ViewAngle, evt.ViewPitch, evt.ViewRoll);
		FracTic = evt.FracTic;
		ViewerFOV = players[consoleplayer].FOV;
		Init();
	}
	
	// This needs to be called *after* ViewPos, ViewAngles, and ViewerFOV are set.
	void Init() {
		// https://forum.zdoom.org/viewtopic.php?f=122&t=61330#p1064117
		WorldToClip = U2P_Matrix.worldToClip(ViewPos, ViewAngles.X, ViewAngles.Y, ViewAngles.Z, ViewerFOV);
	}
}

struct U2P_PlayerState play {
	const ItemsCompactSize = 3;
	
	Array<U2P_ItemHighlight> Items;
	U2P_ItemHighlight FocusedItem;
	PlayerInfo Player;
	bool IsEnabled;
	CVar IsEnabledCVar;
	
	void Clear(bool hard = false) {
		IsEnabled = false;
		IsEnabledCVar = null;
		
		if (hard) {
			Items.Clear();
			Items.ShrinkToFit();
		}
		else {
			Items.Resize(min(Items.Size(), ItemsCompactSize));
			
			for (let i = 0, s = Items.Size(); i < s; i++)
			if (Items[i])
				Items[i].Clear();
		}
	}
	
	void FadeOutAll() {
		for (let i = 0, s = Items.Size(); i < s; i++)
		if (Items[i])
			Items[i].Target = null;
	}
	
	void Init(PlayerInfo p) {
		Clear();
		Player = p;
		IsEnabledCVar = CVar.GetCVar('usetopickup_enabled', p);
	}
	
	void Tick() {
		// Periodically clean up excess highlighters, to save memory.
		if (!(gametic & 1023))
		for (uint s = Items.Size(), i = s - 1; i >= 0; i--)
		if (!Items[i] || (!Items[i].InUse && s > ItemsCompactSize)) {
			Items.Delete(i);
			s--;
		}
		
		// Tick (remaining) highlighters that are in use.
		for (uint i = 0, s = Items.Size(); i < s; i++)
		if (Items[i])
			Items[i].Tick();
		
		// Clear the focused item, if appropriate.
		if (FocusedItem && (!FocusedItem.InUse || !FocusedItem.Target))
			FocusedItem = null;
		
		// Update enabled status, PICKUP flag, etc.
		let pp = Player.mo;
		if (!IsEnabledCVar || IsEnabledCVar.GetBool()) {
			IsEnabled = true;
			if (pp)
				pp.bPickup = false;
		}
		else if (IsEnabled) {
			IsEnabled = false;
			if (pp)
				pp.bPickup = GetDefaultByType(pp.GetClass()).bPickup;
			FocusedItem = null;
			FadeOutAll();
		}
		
		if (pp && IsEnabled && !(gametic & 3)) {
			// How far away can this actor pick up items from?
			double range;
			if (usetopickup_fulluserange && pp is "PlayerPawn")
				range = PlayerPawn(pp).UseRange;
			else {
				// TODO: Just check if the actor is touching?
				let pitchVec = Actor.AngleToVector(pp.Pitch);
				range = pp.Radius * abs(pitchVec.X) + pp.Height * abs(pitchVec.Y);
			}
			
			Inventory origTarget, bestTarget;
			double bestDFC = 180;
			bool valid;
			
			// Check the current focused item.
			if (FocusedItem) {
				origTarget = FocusedItem.Target;
				if (IsBetterTarget(pp, origTarget, range, bestDFC)) {
					bestTarget = origTarget;
				}
				else {
					// Current focused item is no longer valid, so defocus it.
					FocusedItem.Target = null;
					FocusedItem = null;
					origTarget = null;
				}
			}
			
			// Look for the item that's closest to the center of the player actor's field of view.
			for (let i = BlockThingsIterator.Create(pp, range); i.Next();)
			if (i.thing != bestTarget && i.thing is "Inventory" && i.thing.bSpecial) {
				if (IsBetterTarget(pp, i.thing, range, bestDFC))
					bestTarget = Inventory(i.thing);
			}
			
			if (FocusedItem && (!bestTarget || bestTarget != origTarget)) {
				// If we need to defocus the currently focused target, do that now.
				FocusedItem.Target = null;
				FocusedItem = null;
			}
			
			if (bestTarget && bestTarget != origTarget) {
				// Got a new target to focus on.
				// Find a free slot in the Items array, if any. Otherwise, allocate a new one.
				uint i = 0, s = Items.Size();
				
				for (; i < s; i++)
				if (!Items[i] || !Items[i].InUse)
					break;
				
				if (i == s) {
					// We've run out of available slots.
					FocusedItem = new("U2P_ItemHighlight");
					let slot = Items.Push(FocusedItem);
				}
				else if (!Items[i]) {
					// Found a null slot. Fill it.
					FocusedItem = new("U2P_ItemHighlight");
					Items[i] = FocusedItem;
				}
				else
					// Found an existing, filled but unused slot.
					FocusedItem = Items[i];
				
				// In any case, set it up.
				FocusedItem.Target = bestTarget;
				FocusedItem.Tick();
			}
		}
		
		// Check if the player wants and is allowed to pick up the focused item.
		if (
			IsEnabled &&
			pp &&
			(Player.cmd.buttons & BT_USE) &&
			!(Player.oldbuttons & BT_USE) &&
			FocusedItem &&
			FocusedItem.Target &&
			FocusedItem.Opacity == 1.
		) {
			FocusedItem.Target.Touch(pp);
		}
	}
	
	/**
	 * Checks whether a target is valid, and if so, updates bestDFC.
	 *
	 * The target is valid if:
	 * • It is within the given range of the viewer.
	 * • Its distance from the center of the viewer's field of view (that is, how far the viewer would need to look left/right/up/down to look straight at the target) is less than bestDFC.
	 *
	 * @param viewer The viewing actor.
	 * @param target The actor that may or may not be a valid target.
	 * @param range How far away the target may be.
	 * @param bestDFC Distance-from-center of currently focused target. This is an out parameter; if the given target is valid, bestDFC will be updated with the DFC of the given target.
	 * @return true if the target is valid; false otherwise.
	 */
	static bool IsBetterTarget(Actor viewer, Actor target, double range, in out double bestDFC) {
		if (
			// Does it exist at all?
			!target ||
			// Is it in range?
			viewer.Distance3D(target) > range
		)
			// Nope.
			return false;
		
		let vecTo = viewer.Vec3To(target);
		
		// Correct for the center of target, and the view height of viewer.
		vecTo.Z += target.Height / 2.;
		vecTo.Z -= viewer.player? viewer.player.viewheight : viewer.Height / 2;
		
		let dirTo = vecTo.Unit();
		Vector2 viewDA = (
			Actor.deltaangle(viewer.AngleTo(target), viewer.Angle),
			Actor.deltaangle(-asin(dirTo.Z), viewer.Pitch)
		);
		let dfc = viewDA.Length();
		
		// Is it within acceptable angles?
		if (dfc < bestDFC) {
			bestDFC = dfc;
			return true;
		}
		else
			return false;
	}
	
	ui void Draw(U2P_DrawContext dc) const {
		for (uint i = 0, s = Items.Size(); i < s; i++)
		if (Items[i] && Items[i].InUse)
			Items[i].Draw(dc);
	}
}

class U2P_ItemHighlight {
	const FadeInRate = float(.14);
	const FadeOutRate = float(-.07);
	
	Inventory Target;
	float Opacity;
	protected float OpacityIncrement;
	bool InUse, Ready;
	
	// Record this information so that the highlight can fade out, even if the item disappears.
	Vector3 TargetPos;
	double TargetHeight, TargetRadius;
	String TargetTag;
	
	void Clear() {
		Ready = InUse = false;
		Target = null;
		TargetTag = "";
		OpacityIncrement = Opacity = 0;
	}
	
	play void Tick() {
		if (Target) {
			if (Opacity < 1.)
				OpacityIncrement = FadeInRate;
			
			TargetPos = Target.Pos;
			TargetTag = Target.GetTag(Target.GetClassName());
			TargetHeight = Target.Height;
			TargetRadius = Target.Radius;
		}
		else {
			if (Opacity > 0.)
				OpacityIncrement = FadeOutRate;
		}
		
		if (OpacityIncrement)
			Opacity = clamp(Opacity + OpacityIncrement, 0., 1.);
		
		if (InUse && Opacity == 0. && !Target)
			Clear();
		else {
			InUse = Target || Opacity > 0.;
			Ready = Target && Opacity == 1.;
			
			if (Ready)
				OpacityIncrement = 0;
		}
	}
	
	const TextColor_Description = Font.CR_WHITE;
	const TextColor_KeyBind = Font.CR_GRAY;
	const TextColor_PressToUseMsg = Font.CR_WHITE;
	const BackgroundColor_KeyBind = Color(0xffffffe6);
	
	ui void Draw(U2P_DrawContext dc) const {
		if (!InUse)
			return;
		
		// Top left, bottom right
		Vector2 screenCoord[2];
		
		// Adapted from Pixel Eater's Fill Spectre.
		for (let corner = 0; corner < 4; corner++) {
			// Compute one corner at a time.
			// The corner numbers are: 0 = top left, 1 = top right, 2 = bottom left, 3 = bottom right
			let vert = dc.ViewPos + LevelLocals.Vec3Diff(
				dc.ViewPos,
				TargetPos + (
					// `corner & 1` is only true for the top right and bottom right corners.
					sin(dc.Viewer.Angle) * TargetRadius * (corner & 1? 1. : -1.),
					cos(dc.Viewer.Angle) * TargetRadius * (corner & 1? -1. : 1.),
					// `corner & 2` is only true for the bottom left and bottom right corners.
					corner & 2? 0 : TargetHeight
				)
			);
			
			let ndc = dc.WorldToClip.multiplyVector3(vert).asVector3();
			
			if (ndc.Z > 1. || ndc.Z < -1.)
				// Out of camera view. Don't draw anything.
				// This is the reason why we store all four coordinates in the screenCoord and then loop over them again: if *any* of the coordinates are out of view, we need to not draw anything!
				return;
			
			let cornerCoord = U2P_GlobalMaths.ndcToViewPort(ndc);
			
			// That projects the corners of the sprite on the screen. Now, make a rectangle from the coordinates.
			if (!corner) {
				// For the first corner, just use that coordinate to start.
				screenCoord[0] = screenCoord[1] = cornerCoord;
			}
			else {
				// From there, stretch out the rectangle to fit the thing.
				screenCoord[0].X = min(screenCoord[0].X, cornerCoord.X);
				screenCoord[0].Y = min(screenCoord[0].Y, cornerCoord.Y);
				screenCoord[1].X = max(screenCoord[1].X, cornerCoord.X);
				screenCoord[1].Y = max(screenCoord[1].Y, cornerCoord.Y);
			}
		}
		
		for (let corner = 0; corner < 4; corner++) {
			Screen.DrawText(
				dc.MsgFont, TextColor_Description,
				screenCoord[corner & 1].X,
				// (2 & 2) = 2, but we need 0 or 1. !! gives us that.
				screenCoord[!!(corner & 2)].Y,
				String.Format("%d", corner),
				DTA_Alpha, Opacity,
				DTA_CleanNoMove, true
			);
		}
	}
}
